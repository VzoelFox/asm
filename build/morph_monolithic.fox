; ============================================================================
; MORPH SELF-HOSTED COMPILER - MONOLITHIC BUILD
; Generated by tools/merge_source.sh
; ============================================================================

; === STANDARD LIBRARY ===

; --- buffer.fox ---
struktur MemoryBuffer
  data_ptr int
  size int
  capacity int
  position int
  is_readonly int
tutup_struktur

fungsi buffer_buat(capacity)
  var buf = MemoryBuffer(0, 0, capacity, 0, 0)
  var ptr = 0

  ; Allocate raw memory
  asm_mulai
  mov rax, [var_capacity]
  call sys_alloc
  mov [var_ptr], rax
  tutup_asm

  buf.data_ptr = ptr

  ; Return buf (pointer to struct)
  asm_mulai
  mov rax, [var_buf]
  tutup_asm
tutup_fungsi

fungsi buffer_tulis(buf, data)
  tipe buf MemoryBuffer
  ; Check if readonly
  var ro = buf.is_readonly
  jika (ro == 1)
    var err = -1
    asm_mulai
    mov rax, -1
    tutup_asm
    cetak("Error: Buffer is Read-Only")
    ; Return -1 logic is implicit in RAX
  lain
    ; Calculate length of data string
    var len = 0
    asm_mulai
    mov rsi, [var_data]
    call sys_strlen
    mov [var_len], rax
    tutup_asm

    ; TODO: Check capacity (buf.position + len <= buf.capacity)

    ; Perform memcpy(dest=buf.data_ptr + buf.position, src=data, len=len)
    asm_mulai
    mov rbx, [var_buf]      ; rbx = struct ptr
    mov rdi, [rbx]          ; rdi = buf.data_ptr (offset 0)

    mov rcx, [rbx + 24]     ; rcx = buf.position (offset 24: 0,8,16,24)
    add rdi, rcx            ; rdi = destination address

    mov rsi, [var_data]     ; rsi = source
    mov rcx, [var_len]      ; rcx = length
    call sys_memcpy
    tutup_asm

    ; Update position
    ; Cannot do: buf.position = buf.position + len
    var pos = buf.position
    pos = pos + len
    buf.position = pos

    ; Update size (if pos > size)
    var sz = buf.size
    jika (pos > sz)
      buf.size = pos
    tutup_jika

    ; Return bytes written
    asm_mulai
    mov rax, [var_len]
    tutup_asm
  tutup_jika
tutup_fungsi

fungsi buffer_baca(buf, size)
  tipe buf MemoryBuffer
  ; Read 'size' bytes from current position
  ; Allocate new string buffer for result
  var res_ptr = 0

  asm_mulai
  ; 1. Alloc (size + 1)
  mov rax, [var_size]
  inc rax
  call sys_alloc
  mov [var_res_ptr], rax

  ; 2. Memcpy
  mov rbx, [var_buf]
  mov rsi, [rbx]          ; rsi = buf.data_ptr
  mov rcx, [rbx + 24]     ; rcx = buf.position
  add rsi, rcx            ; rsi = source (data + pos)

  mov rdi, [var_res_ptr]  ; rdi = dest
  mov rcx, [var_size]     ; rcx = count
  call sys_memcpy

  ; 3. Null terminate
  mov rdi, [var_res_ptr]
  add rdi, [var_size]
  mov byte [rdi], 0
  tutup_asm

  ; Update position
  ; buf.position = buf.position + size
  var pos = buf.position
  pos = pos + size
  buf.position = pos

  ; Return result string
  asm_mulai
  mov rax, [var_res_ptr]
  tutup_asm
tutup_fungsi

fungsi buffer_seek(buf, pos)
  tipe buf MemoryBuffer
  jika (pos >= 0)
    var sz = buf.size
    jika (pos <= sz)
      buf.position = pos
      var ok = 1
      asm_mulai
      mov rax, 1
      tutup_asm
    lain
      var err = 0
      asm_mulai
      mov rax, 0
      tutup_asm
    tutup_jika
  lain
    ; pos < 0
    var err2 = 0
    asm_mulai
    mov rax, 0
    tutup_asm
  tutup_jika
tutup_fungsi

fungsi buffer_size(buf)
  tipe buf MemoryBuffer
  var s = buf.size
  asm_mulai
  mov rax, [var_s]
  tutup_asm
tutup_fungsi

fungsi buffer_reset(buf)
  tipe buf MemoryBuffer
  buf.size = 0
  buf.position = 0
tutup_fungsi

fungsi buffer_readonly(buf)
  tipe buf MemoryBuffer
  buf.is_readonly = 1
tutup_fungsi

; --- file_io.fox ---
fungsi buffer_dari_file(filepath)
  ; 1. Open File
  var fd = 0
  asm_mulai
  mov rsi, [var_filepath]
  mov rdx, 0 ; RDONLY
  call sys_open
  mov [var_fd], rax
  tutup_asm

  jika (fd < 0)
    cetak("Error: Cannot open file")
    var null = 0
    asm_mulai
    mov rax, 0
    tutup_asm
  lain
    ; 2. Read Content (Assume max 1MB for now, chunking later)
    var size = 1048576
    var content_ptr = 0
    var bytes_read = 0

    asm_mulai
    mov rdi, [var_fd]
    mov rsi, [var_size]
    call sys_read_fd
    mov [var_content_ptr], rax
    mov [var_bytes_read], rdx
    tutup_asm

    ; 3. Close File
    asm_mulai
    mov rdi, [var_fd]
    call sys_close
    tutup_asm

    ; 4. Create Buffer Wrapper
    var buf = MemoryBuffer(content_ptr, bytes_read, size, 0, 1)

    asm_mulai
    mov rax, [var_buf]
    tutup_asm
  tutup_jika
tutup_fungsi

fungsi file_write_str(filepath, content)
  ; Flags: O_WRONLY(1) | O_CREAT(64) | O_TRUNC(512) = 577
  ; Mode: 0644 (420 decimal)
  var flags = 577
  var mode = 420

  var fd = 0
  asm_mulai
  mov rsi, [var_filepath]
  mov rdx, [var_flags]
  mov rax, 2 ; sys_open
  mov rdi, rsi
  mov rsi, rdx
  mov rdx, [var_mode]
  syscall
  mov [var_fd], rax
  tutup_asm

  jika (fd < 0)
     cetak("Error: Cannot open file for writing")
  lain
     var len = str_len(content)
     asm_mulai
     mov rdi, [var_fd]
     mov rsi, [var_content]
     mov rdx, [var_len]
     call sys_write_fd
     tutup_asm

     asm_mulai
     mov rdi, [var_fd]
     call sys_close
     tutup_asm
  tutup_jika
tutup_fungsi

; --- format.fox ---
struktur FormatBuffer
  data_ptr int
  length int
  capacity int
tutup_struktur

fungsi format_buffer_buat(capacity)
  var buf = FormatBuffer(0, 0, capacity)
  var ptr = 0

  ; Allocate raw memory for data
  asm_mulai
  mov rax, [var_capacity]
  call sys_alloc
  mov [var_ptr], rax
  ; Initialize with empty string (null terminator at start)
  mov byte [rax], 0
  tutup_asm

  buf.data_ptr = ptr

  ; Return struct pointer
  asm_mulai
  mov rax, [var_buf]
  tutup_asm
tutup_fungsi

fungsi format_append(buf, text)
  ; Logic: concat current data + text
  ; Current data is at buf.data_ptr
  ; We can reuse sys_str_concat, but we need to update the pointer in buf.data_ptr
  ; NOTE: sys_str_concat allocates NEW memory. This is simple but leaks old memory (no GC yet).
  ; It's acceptable for now.

  var old_ptr = buf.data_ptr
  var new_ptr = 0

  asm_mulai
  mov rsi, [var_old_ptr]
  mov rdx, [var_text]
  call sys_str_concat
  mov [var_new_ptr], rax
  tutup_asm

  buf.data_ptr = new_ptr

  ; Update length
  var len = 0
  asm_mulai
  mov rsi, [var_new_ptr]
  call sys_strlen
  mov [var_len], rax
  tutup_asm

  buf.length = len

  ; Return buffer ptr
  asm_mulai
  mov rax, [var_buf]
  tutup_asm
tutup_fungsi

fungsi format_int(value)
  ; Convert int to string
  ; We don't have a direct helper for this exposed yet, but print_int logic exists in codegen.
  ; We need a sys_int_to_str helper or implement it here.
  ; Implementing here in ASM is cleaner for library.

  var res_ptr = 0

  asm_mulai
  ; Alloc 32 bytes for buffer
  mov rax, 32
  call sys_alloc
  mov [var_res_ptr], rax

  mov rdi, rax          ; RDI = buffer start
  mov rax, [var_value]  ; RAX = integer value

  ; Handle 0
  cmp rax, 0
  jne .check_sign
  mov byte [rdi], '0'
  mov byte [rdi+1], 0
  jmp .done_fmt

.check_sign:
  mov rbx, 0            ; Is negative?
  test rax, rax
  jns .convert
  neg rax
  mov rbx, 1            ; Set negative flag

.convert:
  mov rcx, 10
  mov rsi, rdi          ; Save start
  add rdi, 20           ; Start filling from end (safe margin)
  mov byte [rdi], 0     ; Null terminator
  dec rdi

.loop:
  xor rdx, rdx
  div rcx
  add dl, '0'
  mov [rdi], dl
  dec rdi
  test rax, rax
  jnz .loop

  ; Add sign if needed
  cmp rbx, 1
  jne .finalize
  mov byte [rdi], '-'
  dec rdi

.finalize:
  inc rdi               ; Point to first char

  ; Move to beginning of buffer (optional, but good for neatness)
  ; rdi is current start, rsi is allocated start.
  ; sys_memcpy(dest=rsi, src=rdi, len=strlen(rdi)+1)

  push rsi
  push rdi

  ; Calc length
  push rdi
  pop rsi               ; RSI = src string
  call sys_strlen
  mov rcx, rax
  inc rcx               ; + null terminator

  pop rdi               ; Restore src
  pop rsi               ; Restore dest (allocated start)

  push rdi
  pop rdx               ; RDX = src (swap for helper if needed, but we do manual rep movsb)

  ; Manual copy
  mov rsi, rdx          ; Source
  mov rdi, rsi          ; Dest (Wait, rsi was popped as allocated start. So RDI = allocated start)
                        ; Ah, stack management above is confusing.
                        ; Let's just return the pointer inside the buffer?
                        ; No, 'sys_alloc' returns [ptr].
                        ; If we return ptr+offset, we waste memory but it works.
                        ; Let's simpler: just return RDI (the start of valid string).
                        ; BUT we need to store it in [var_res_ptr] if we want to return it.

  ; Correct logic: Move string to start of buffer so we return the malloc'd pointer
  ; rsi (popped) = allocated start
  ; rdx (current) = string start
  ; rcx (calculated) = length + 1

  mov rdi, rsi          ; Dest = allocated start
  mov rsi, rdx          ; Src = current pos inside buffer

  ; Rep Movsb
  cld
  rep movsb

  ; Now string is at allocated start.
  ; [var_res_ptr] already holds the allocated start address.

.done_fmt:
  tutup_asm

  asm_mulai
  mov rax, [var_res_ptr]
  tutup_asm
tutup_fungsi

fungsi format_bool(value)
  var res = ""
  jika (value == 1)
     res = "true"
  lain
     res = "false"
  tutup_jika

  asm_mulai
  mov rax, [var_res]
  tutup_asm
tutup_fungsi

fungsi format_print(text)
  cetak_str(text)
tutup_fungsi

; --- hashmap.fox ---
fungsi hash_djb2(key)
  ; DJB2 Hash Algorithm
  var hash = 5381

  asm_mulai
  mov rsi, [var_key]
  mov rax, 5381
  xor rcx, rcx
.hash_loop:
  mov cl, byte [rsi]
  test cl, cl
  jz .hash_done
  mov rdx, rax
  shl rdx, 5
  add rdx, rax
  add rdx, rcx
  mov rax, rdx
  inc rsi
  jmp .hash_loop
.hash_done:
  mov [var_hash], rax
  tutup_asm

  asm_mulai
  mov rax, [var_hash]
  tutup_asm
tutup_fungsi

struktur HashNode
  key int
  value int
  next int
tutup_struktur

struktur HashMap
  buckets int
  capacity int
tutup_struktur

fungsi map_create(capacity)
  var map = HashMap(0, capacity)

  ; Allocate buckets array
  var buckets_size = capacity * 8
  var b_ptr = 0

  asm_mulai
  mov rax, [var_buckets_size]
  call sys_alloc
  mov [var_b_ptr], rax
  ; Zero out
  mov rdi, rax
  mov rcx, [var_capacity]
  xor rax, rax
  rep stosq
  tutup_asm

  tipe map HashMap
  map.buckets = b_ptr

  asm_mulai
  mov rax, [var_map]
  tutup_asm
tutup_fungsi

fungsi map_put(map, key, value)
  tipe map HashMap

  ; 1. Calculate Hash
  var h = hash_djb2(key)

  ; 2. Calculate Index
  var cap = map.capacity
  var idx = 0

  asm_mulai
  mov rax, [var_h]
  xor rdx, rdx
  mov rbx, [var_cap]
  div rbx
  mov [var_idx], rdx
  tutup_asm

  ; 3. Get Bucket Ptr
  var buckets_base = map.buckets
  var head_node_ptr = 0

  ; Array read: buckets_base[idx] -> ASM
  asm_mulai
  mov rbx, [var_buckets_base]
  mov rcx, [var_idx]
  mov rax, [rbx + rcx * 8]
  mov [var_head_node_ptr], rax
  tutup_asm

  ; 4. Iterate List
  var curr = head_node_ptr
  var found = 0

  selama (curr != 0)
    tipe curr HashNode
    var curr_key = curr.key

    var is_eq = str_eq(curr_key, key)
    jika (is_eq == 1)
       curr.value = value
       found = 1
       curr = 0 ; Break
    lain
       curr = curr.next
    tutup_jika
  tutup_selama

  ; 5. Insert New Node
  jika (found == 0)
    var new_node_ptr = HashNode(key, value, head_node_ptr)

    ; buckets_base[idx] = new_node_ptr
    ; Parser supports array write: arr[idx] = val
    buckets_base[idx] = new_node_ptr
  tutup_jika
tutup_fungsi

fungsi map_get(map, key)
  tipe map HashMap

  ; 1. Calculate Hash
  var h = hash_djb2(key)

  ; 2. Index
  var cap = map.capacity
  var idx = 0

  asm_mulai
  mov rax, [var_h]
  xor rdx, rdx
  mov rbx, [var_cap]
  div rbx
  mov [var_idx], rdx
  tutup_asm

  ; 3. Get Head
  var buckets_base = map.buckets
  var curr = 0

  ; Array read: ASM
  asm_mulai
  mov rbx, [var_buckets_base]
  mov rcx, [var_idx]
  mov rax, [rbx + rcx * 8]
  mov [var_curr], rax
  tutup_asm

  var result = -1

  selama (curr != 0)
    tipe curr HashNode
    var curr_key = curr.key

    var is_eq = str_eq(curr_key, key)
    jika (is_eq == 1)
       result = curr.value
       curr = 0 ; Break
    lain
       curr = curr.next
    tutup_jika
  tutup_selama

  asm_mulai
  mov rax, [var_result]
  tutup_asm
tutup_fungsi

; --- vector.fox ---
struktur Vector
  data_ptr int
  size int
  capacity int
tutup_struktur

fungsi vec_create(capacity)
  var vec = Vector(0, 0, capacity)

  ; Alloc data array (capacity * 8)
  var byte_size = capacity * 8

  asm_mulai
  mov rax, [var_byte_size]
  call sys_alloc
  mov [var_byte_size], rax
  tutup_asm

  ; Store to vec.data_ptr
  ; Note: vec is a pointer, so we need 'tipe' to access fields
  tipe vec Vector
  vec.data_ptr = byte_size ; byte_size variable holds the pointer now

  asm_mulai
  mov rax, [var_vec]
  tutup_asm
tutup_fungsi

fungsi vec_push(vec, value)
  tipe vec Vector

  var sz = vec.size
  var cap = vec.capacity

  ; 2. Check resize
  jika (sz >= cap)
     ; Grow capacity (double)
     var new_cap = cap * 2
     jika (new_cap == 0)
        new_cap = 4
     tutup_jika

     ; Alloc new array
     var new_byte_size = new_cap * 8
     var new_ptr = 0

     asm_mulai
     mov rax, [var_new_byte_size]
     call sys_alloc
     mov [var_new_ptr], rax
     tutup_asm

     ; Copy old to new
     var copy_size = sz * 8
     var old_ptr = vec.data_ptr

     asm_mulai
     mov rdi, [var_new_ptr]
     mov rsi, [var_old_ptr]
     mov rcx, [var_copy_size]
     call sys_memcpy
     tutup_asm

     ; Update vec
     vec.data_ptr = new_ptr
     vec.capacity = new_cap
     cap = new_cap
  tutup_jika

  ; 3. Append value
  ; vec.data[sz] = value
  ; Accessing raw array still needs manual ASM or trick
  ; Trick: var arr = vec.data_ptr -> then arr[sz] = value?
  ; Parser supports 'arr[idx] = val' but assumes 'arr' is a variable holding pointer.
  ; Let's try that.

  var arr = vec.data_ptr
  arr[sz] = value

  ; vec.size++
  var new_sz = sz + 1
  vec.size = new_sz

  asm_mulai
  mov rax, [var_new_sz]
  tutup_asm
tutup_fungsi

fungsi vec_get(vec, index)
  tipe vec Vector

  var arr = vec.data_ptr

  ; We can't do 'var val = arr[index]' directly in parser?
  ; Parser: 'var name = expr'. If expr is 'arr[index]'?
  ; Parser check: 'cetak(arr[idx])' works. 'arr[idx] = val' works.
  ; 'var x = arr[idx]'?
  ; Check parser.sh 'var' handler...
  ; It handles: 'struct(...)', 'func(...)', 'op1 op op2', 'string', 'number/var'.
  ; It DOES NOT handle 'var x = arr[idx]'.
  ; So we need ASM for reading array element to variable, OR update parser.
  ; For now, keep ASM for array read to avoid blocking refactor.

  var val = 0
  asm_mulai
  mov rbx, [var_arr]  ; Array base
  mov rcx, [var_index]
  mov rax, [rbx + rcx * 8]
  mov [var_val], rax
  tutup_asm

  asm_mulai
  mov rax, [var_val]
  tutup_asm
tutup_fungsi

fungsi vec_set(vec, index, value)
  tipe vec Vector
  var arr = vec.data_ptr

  ; Parser supports: arr[index] = value
  arr[index] = value
tutup_fungsi

fungsi vec_len(vec)
  tipe vec Vector
  var sz = vec.size
  asm_mulai
  mov rax, [var_sz]
  tutup_asm
tutup_fungsi

; --- string_utils.fox ---
fungsi str_len(s)
  var len = 0
  asm_mulai
  mov rsi, [var_s]
  call sys_strlen
  mov [var_len], rax
  tutup_asm
  asm_mulai
  mov rax, [var_len]
  tutup_asm
tutup_fungsi

fungsi str_slice(s, start, len)
  var new_ptr = 0
  asm_mulai
  ; Alloc
  mov rax, [var_len]
  inc rax
  call sys_alloc
  mov [var_new_ptr], rax

  ; Copy
  mov rdi, rax         ; dest
  mov rsi, [var_s]     ; source base
  add rsi, [var_start] ; source offset
  mov rcx, [var_len]   ; count
  call sys_memcpy

  ; Null terminate
  mov rdi, [var_new_ptr]
  add rdi, [var_len]
  mov byte [rdi], 0
  tutup_asm

  asm_mulai
  mov rax, [var_new_ptr]
  tutup_asm
tutup_fungsi

fungsi str_get(str_ptr, idx_val)
  ; Get byte at index from string s
  ; Renamed args to avoid collision with callers using 's' or 'i'/'index'
  var val = 0
  asm_mulai
  mov rsi, [var_str_ptr]
  mov rbx, [var_idx_val]
  add rsi, rbx
  xor rax, rax
  mov al, [rsi]
  mov [var_val], rax
  tutup_asm

  asm_mulai
  mov rax, [var_val]
  tutup_asm
tutup_fungsi

fungsi str_trim(s)
  var len = str_len(s)
  var start = 0
  var end = len - 1

  ; Find start
  var loop = 1
  selama (loop == 1)
     jika (start >= len)
       loop = 0
     lain
       var ch = str_get(s, start)
       ; 32=space, 9=tab, 10=nl
       jika (ch == 32)
         start = start + 1
       lain_jika (ch == 9)
         start = start + 1
       lain_jika (ch == 10)
         start = start + 1
       lain
         loop = 0
       tutup_jika
     tutup_jika
  tutup_selama

  ; Find end
  loop = 1
  selama (loop == 1)
     jika (end < start)
       loop = 0
     lain
       var ch = str_get(s, end)
       jika (ch == 32)
         end = end - 1
       lain_jika (ch == 9)
         end = end - 1
       lain_jika (ch == 10)
         end = end - 1
       lain
         loop = 0
       tutup_jika
     tutup_jika
  tutup_selama

  var new_len = end - start
  new_len = new_len + 1

  jika (new_len <= 0)
     var empty = ""
     asm_mulai
     mov rax, [var_empty]
     tutup_asm
  lain
     var res = str_slice(s, start, new_len)
     asm_mulai
     mov rax, [var_res]
     tutup_asm
  tutup_jika
tutup_fungsi

fungsi str_split_lines(content, vec)
  ; Renamed vars to avoid collision with global vars in other functions
  var content_len = str_len(content)
  var current_start = 0
  var idx = 0

  selama (idx < content_len)
    var ch = str_get(content, idx)
    jika (ch == 10)
      ; Newline found
      var line_len = idx - current_start
      var line = str_slice(content, current_start, line_len)
      panggil vec_push(vec, line)
      current_start = idx + 1
    tutup_jika
    idx = idx + 1
  tutup_selama

  ; Last line
  jika (current_start < content_len)
     var last_len = content_len - current_start
     var last_line = str_slice(content, current_start, last_len)
     panggil vec_push(vec, last_line)
  tutup_jika
tutup_fungsi

fungsi str_starts_with(target_str, prefix_str)
  ; Renamed args to prevent 'var_s' collision with str_len/str_get
  var len_p = str_len(prefix_str)
  var len_s = str_len(target_str)
  var res_bool = 0

  jika (len_s >= len_p)
    ; Check bytes
    var match = 1
    var i = 0
    selama (i < len_p)
      var c1 = str_get(target_str, i)
      var c2 = str_get(prefix_str, i)

      jika (c1 != c2)
        match = 0
        i = len_p ; break
      tutup_jika
      i = i + 1
    tutup_selama
    res_bool = match
  tutup_jika

  asm_mulai
  mov rax, [var_res_bool]
  tutup_asm
tutup_fungsi

fungsi str_split_once(s, delim_char)
   ; Returns Vector of size 2. [0]=left, [1]=right.
   ; If delim not found, [0]=s, [1]=""

   var str_len_val = str_len(s)
   var i = 0
   var found = -1

   selama (i < str_len_val)
     var ch = str_get(s, i)
     jika (ch == delim_char)
       found = i
       i = str_len_val ; break
     tutup_jika
     i = i + 1
   tutup_selama

   var v = vec_create(2)

   jika (found == -1)
      panggil vec_push(v, s)
      panggil vec_push(v, "")
   lain
      var left = str_slice(s, 0, found)
      var right_start = found + 1
      var right_len = str_len_val - right_start
      var right = str_slice(s, right_start, right_len)
      panggil vec_push(v, left)
      panggil vec_push(v, right)
   tutup_jika

   asm_mulai
   mov rax, [var_v]
   tutup_asm
tutup_fungsi

fungsi str_substring_after(s, start_index)
  var len_sub = str_len(s)
  var res_str = ""
  jika (start_index < len_sub)
     var new_len = len_sub - start_index
     var temp = str_slice(s, start_index, new_len)
     res_str = temp
  tutup_jika
  asm_mulai
  mov rax, [var_res_str]
  tutup_asm
tutup_fungsi

fungsi str_newline()
  var nl_ptr = 0
  asm_mulai
  jmp .nl_end
.nl_start:
  db 10, 0
.nl_end:
  mov rax, .nl_start
  mov [var_nl_ptr], rax
  tutup_asm
  asm_mulai
  mov rax, [var_nl_ptr]
  tutup_asm
tutup_fungsi

; === COMPILER CORE ===

; --- globals.fox ---
; Global Variables for Self-Hosted Compiler
; Shared state across parser, codegen, and type system
; NOTE: No Ambil here - inherits from main.fox parent
; ID Range: 1010-1011

; Global Output Buffer
var output_lines = 0
var global_vars = 0

; Global Stack for Control Flow (If/Loop)
var label_stack = 0
var label_counter = 0

; String Literal Counter (for cetak)
var str_counter = 0

; Parser State
var current_func = ""

; Import Guard
var processed_files = 0

; Struct Tracking
var struct_sizes = 0
var struct_offsets = 0
var struct_names = 0
var current_struct_name = ""
var in_struct_block = 0

fungsi init_globals()
  var temp_out = vec_create(1000)
  output_lines = temp_out
  var temp_vars = vec_create(100)
  global_vars = temp_vars
  var temp_stack = vec_create(50)
  label_stack = temp_stack
  var temp_map = map_create(32)
  processed_files = temp_map

  ; Init Struct Tracking
  var ss_map = map_create(32)
  struct_sizes = ss_map
  var so_map = map_create(128)
  struct_offsets = so_map
  var sn_vec = vec_create(16)
  struct_names = sn_vec
tutup_fungsi

; --- constants.fox ---
; String Constants for Assembly Code Generation
; These are initialized at runtime to avoid bootstrap parser issues
; NOTE: No Ambil here - inherits from main.fox parent
; ID Range: 1020-1021


; --- GLOBAL CONSTANTS (Declarations) ---
var s_msg_skip = 0
var s_colon = 0
var s_push_q = 0
var s_close_br = 0
var s_mov_mem = 0
var s_comma_space = 0

var s_mov_rax_v = 0
var s_mov_rbx_v = 0
var s_cmp_rax = 0
var s_cmp_rax_v = 0

var s_jne = 0
var s_jge = 0
var s_jle = 0

var s_end_lbl = 0
var s_final_lbl = 0
var s_jmp = 0

var s_loop_start = 0
var s_loop_end = 0

var s_mov_rax = 0
var s_var_pref = 0

var s_add = 0
var s_sub = 0
var s_mul = 0
var s_op_mem = 0

var s_mov_mem_raw = 0
var s_end_mem = 0

var s_mov_rsi_v = 0

var s_msg = 0
var s_len = 0
var s_data = 0
var s_db = 0
var s_db_end = 0
var s_equ = 0
var s_text = 0

var s_mov_rsi_lit = 0
var s_mov_rdx_lit = 0

var s_mov_reg = 0
var s_comma = 0
var s_comma_mem = 0
var s_call = 0

var s_indent = 0

var s_print = 0
var s_nl = 0
var s_print_int = 0
var s_print_ptr = 0

fungsi init_constants()
  s_msg_skip = "Skipped already imported: "
  s_colon = ":"
  s_push_q = "    push qword [var_"
  s_close_br = "]"
  s_mov_mem = "    mov [var_"
  s_comma_space = "], "

  s_mov_rax_v = "    mov rax, [var_"
  s_mov_rbx_v = "    mov rbx, [var_"
  s_cmp_rax = "    cmp rax, "
  s_cmp_rax_v = "    cmp rax, [var_"

  s_jne = "    jne "
  s_jge = "    jge "
  s_jle = "    jle "

  s_end_lbl = ".L_end_"
  s_final_lbl = ".L_final_"
  s_jmp = "    jmp "

  s_loop_start = ".L_loop_start_"
  s_loop_end = ".L_loop_end_"

  s_mov_rax = "    mov rax, "
  s_var_pref = "var_"

  s_add = "    add rax, "
  s_sub = "    sub rax, "
  s_mul = "    imul rax, "
  s_op_mem = "[var_"

  s_mov_mem_raw = "    mov ["
  s_end_mem = "], rax"

  s_mov_rsi_v = "    mov rsi, [var_"

  s_msg = "msg_"
  s_len = "len_"
  s_data = "section .data"
  s_db = " db \""
  s_db_end = "\", 0"
  s_equ = " equ $ - "
  s_text = "section .text"

  s_mov_rsi_lit = "    mov rsi, "
  s_mov_rdx_lit = "    mov rdx, "

  s_mov_reg = "    mov "
  s_comma = ", "
  s_comma_mem = ", [var_"
  s_call = "    call "

  s_indent = "    "

  s_print = "    call print_string"
  s_nl = "    call print_newline"
  s_print_int = "    call print_int"
  s_print_ptr = "    call print_string_ptr"
tutup_fungsi

; --- codegen.fox ---
; Code Generation Utilities
; Functions for emitting assembly code to output buffer
; NOTE: No Ambil here - inherits from main.fox parent
; ID Range: 1030

fungsi emit(line)
  var vec = output_lines
  panggil vec_push(vec, line)
tutup_fungsi

; --- types.fox ---

const TYPE_UNKNOWN = 0
const TYPE_INT = 1
const TYPE_FLOAT = 2
const TYPE_STRING = 3
const TYPE_STRUCT = 4
const TYPE_POINTER = 5
const TYPE_VOID = 6

var var_type_map = 0
var struct_field_types = 0
var type_errors = 0
var type_error_count = 0

fungsi init_type_system()
   var vtm = map_create(256)
   var_type_map = vtm
   var sft = map_create(64)
   struct_field_types = sft
   var errs = vec_create(32)
   type_errors = errs
   type_error_count = 0
tutup_fungsi

fungsi register_variable_type(var_name, type_id)
   var vtm = var_type_map
   panggil map_put(vtm, var_name, type_id)
tutup_fungsi

fungsi register_struct_variable(var_name, struct_name)
   var vtm = var_type_map
   panggil map_put(vtm, var_name, TYPE_STRUCT)
   var key = str_concat("struct_", var_name)
   panggil map_put(vtm, key, struct_name)
tutup_fungsi

fungsi get_variable_type(var_name)
   var vtm = var_type_map
   var type_id = map_get(vtm, var_name)
   jika (type_id == 0)
      asm_mulai
      mov rax, 0
      tutup_asm
      kembalikan
   tutup_jika
   asm_mulai
   mov rax, [var_type_id]
   tutup_asm
   kembalikan
tutup_fungsi

fungsi get_struct_name(var_name)
   var vtm = var_type_map
   var key = str_concat("struct_", var_name)
   var struct_name = map_get(vtm, key)
   asm_mulai
   mov rax, [var_struct_name]
   tutup_asm
   kembalikan
tutup_fungsi

fungsi report_type_errors()
   jika (type_error_count > 0)
      cetak("=== TYPE ERRORS DETECTED ===")
      cetak(type_error_count)
      var errs = type_errors
      var count = vec_len(errs)
      var idx = 0
      selama (idx < count)
         var err_msg = vec_get(errs, idx)
         cetak_str(err_msg)
         idx = idx + 1
      tutup_selama
      cetak("=== COMPILATION FAILED ===")
      asm_mulai
      mov rax, 60
      mov rdi, 1
      syscall
      tutup_asm
   tutup_jika
tutup_fungsi

fungsi infer_literal_type(literal_str)
   var first_ch = str_get(literal_str, 0)
   jika (first_ch == 34)
      asm_mulai
      mov rax, 3
      tutup_asm
      kembalikan
   tutup_jika
   var len = str_len(literal_str)
   var idx = 0
   selama (idx < len)
      var ch = str_get(literal_str, idx)
      jika (ch == 46)
         asm_mulai
         mov rax, 2
         tutup_asm
         kembalikan
      tutup_jika
      idx = idx + 1
   tutup_selama
   asm_mulai
   mov rax, 1
   tutup_asm
   kembalikan
tutup_fungsi

; --- supplier.fox ---

var id_map = 0
var processed_blocks = 0
var block_lines = 0

fungsi init_supplier_system()
   var im = map_create(512)
   id_map = im
   var pb = map_create(256)
   processed_blocks = pb
   var bl = vec_create(100)
   block_lines = bl
tutup_fungsi

fungsi register_id_to_file(id, filepath)
   var im = id_map
   panggil map_put(im, id, filepath)
tutup_fungsi

fungsi get_file_for_id(id)
   var im = id_map
   var filepath = map_get(im, id)
   asm_mulai
   mov rax, [var_filepath]
   ret
   tutup_asm
tutup_fungsi

fungsi is_block_processed(filepath, id)
   var id_str = format_int(id)
   var key = str_concat(filepath, ":")
   key = str_concat(key, id_str)
   var pb = processed_blocks
   var status = map_get(pb, key)
   jika (status == 1)
      asm_mulai
      mov rax, 1
      ret
      tutup_asm
   tutup_jika
   asm_mulai
   mov rax, 0
   ret
   tutup_asm
tutup_fungsi

fungsi mark_block_processed(filepath, id)
   var id_str = format_int(id)
   var key = str_concat(filepath, ":")
   key = str_concat(key, id_str)
   var pb = processed_blocks
   panggil map_put(pb, key, 1)
tutup_fungsi

fungsi parse_daftar_line(line)
   var quote1_idx = str_index_of(line, 34)
   jika (quote1_idx < 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   var after_quote1 = quote1_idx + 1
   var rest1 = str_substring_after(line, after_quote1)
   var quote2_idx = str_index_of(rest1, 34)
   jika (quote2_idx < 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   var filepath = str_slice(rest1, 0, quote2_idx)
   var eq_idx = str_index_of(line, 61)
   jika (eq_idx < 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   var after_eq = eq_idx + 1
   var ids_part = str_substring_after(line, after_eq)
   var ids_trimmed = str_trim(ids_part)
   var dash_idx = str_index_of(ids_trimmed, 45)

   jika (dash_idx >= 0)
      var start_str = str_slice(ids_trimmed, 0, dash_idx)
      var start_trim = str_trim(start_str)
      var start_id = str_to_int(start_trim)
      var after_dash = dash_idx + 1
      var end_str = str_substring_after(ids_trimmed, after_dash)
      var end_trim = str_trim(end_str)
      var end_id = str_to_int(end_trim)
      var current_id = start_id
      selama (current_id <= end_id)
         panggil register_id_to_file(current_id, filepath)
         current_id = current_id + 1
      tutup_selama
   lain
      panggil parse_daftar_list(ids_trimmed, filepath)
   tutup_jika
tutup_fungsi

fungsi parse_daftar_list(ids_trimmed, filepath)
   var id_list = vec_create(20)
   var current_num = ""
   var idx = 0
   var len = str_len(ids_trimmed)

   selama (idx < len)
      var ch = str_get(ids_trimmed, idx)
      jika (ch == 44)
         var num_trim = str_trim(current_num)
         var num_len = str_len(num_trim)
         jika (num_len > 0)
            var id_val = str_to_int(num_trim)
            panggil vec_push(id_list, id_val)
         tutup_jika
         current_num = ""
      lain
         var ch_str = str_slice(ids_trimmed, idx, idx + 1)
         current_num = str_concat(current_num, ch_str)
      tutup_jika
      idx = idx + 1
   tutup_selama

   var last_trim = str_trim(current_num)
   var last_len = str_len(last_trim)
   jika (last_len > 0)
      var last_id = str_to_int(last_trim)
      panggil vec_push(id_list, last_id)
   tutup_jika

   var count = vec_len(id_list)
   var i = 0
   selama (i < count)
      var id = vec_get(id_list, i)
      panggil register_id_to_file(id, filepath)
      i = i + 1
   tutup_selama
tutup_fungsi

fungsi extract_block_by_id(filepath, id, output_vec)
   var buf = buffer_dari_file(filepath)
   jika (buf == 0)
      asm_mulai
      mov rax, 0
      ret
      tutup_asm
   tutup_jika

   tipe buf MemoryBuffer
   var content = buf.data_ptr
   var lines = vec_create(200)
   panggil str_split_lines(content, lines)

   var line_count = vec_len(lines)
   var idx = 0
   var in_target_block = 0
   var found = 0

   selama (idx < line_count)
      var line = vec_get(lines, idx)
      var trimmed = str_trim(line)
      var is_marker = str_starts_with(trimmed, "###")

      jika (is_marker == 1)
         var after_hash = str_substring_after(trimmed, 3)
         var id_str = str_trim(after_hash)
         var marker_id = str_to_int(id_str)

         jika (marker_id == id)
            in_target_block = 1
            found = 1
         lain
            jika (in_target_block == 1)
               asm_mulai
               mov rax, 1
               ret
               tutup_asm
            tutup_jika
         tutup_jika
      lain
         jika (in_target_block == 1)
            panggil vec_push(output_vec, line)
         tutup_jika
      tutup_jika
      idx = idx + 1
   tutup_selama

   jika (found == 1)
      asm_mulai
      mov rax, 1
      ret
      tutup_asm
   tutup_jika

   asm_mulai
   mov rax, 0
   ret
   tutup_asm
tutup_fungsi

fungsi handle_indeks_line(line)
   var quote1_idx = str_index_of(line, 34)
   jika (quote1_idx < 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   var after_quote1 = quote1_idx + 1
   var rest = str_substring_after(line, after_quote1)
   var quote2_idx = str_index_of(rest, 34)
   jika (quote2_idx < 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   var filepath = str_slice(rest, 0, quote2_idx)
   var buf = buffer_dari_file(filepath)
   jika (buf == 0)
      asm_mulai
      ret
      tutup_asm
   tutup_jika

   tipe buf MemoryBuffer
   var content = buf.data_ptr
   var lines = vec_create(100)
   panggil str_split_lines(content, lines)

   var line_count = vec_len(lines)
   var idx = 0

   selama (idx < line_count)
      var registry_line = vec_get(lines, idx)
      var trimmed = str_trim(registry_line)
      var is_daftar = str_starts_with(trimmed, "Daftar")
      jika (is_daftar == 1)
         panggil parse_daftar_line(trimmed)
      tutup_jika
      idx = idx + 1
   tutup_selama
tutup_fungsi

; === PARSER HELPERS ===

; --- parser_helpers_fungsi.fox ---
; Parser Helpers - Flow Control Logic
; Handles: fungsi, tutup_fungsi, jika, lain, lain_jika, tutup_jika, selama, tutup_selama
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi handle_fungsi_begin(line)
   ; Handle: fungsi func_name(param1, param2, ...)
   ; Emit function prologue and parameter handling

   var func_decl_full = str_substring_after(line, 6)
   var func_decl = str_trim(func_decl_full)
   var f_parts = str_split_once(func_decl, 40)
   var f_name_raw = vec_get(f_parts, 0)
   var f_name_clean = str_trim(f_name_raw)

   cetak("[CODEGEN] Function: ")
   cetak_str(f_name_clean)
   current_func = f_name_clean

   var label = str_concat(f_name_clean, s_colon)
   panggil emit(label)
   panggil emit("    push rbp")

   var func_prologue = "    mov rbp, rsp"
   panggil emit(func_prologue)

   var f_args_raw = vec_get(f_parts, 1)
   jika (f_args_raw != 0)
      var f_args_len = str_len(f_args_raw)
      jika (f_args_len > 0)
         var last_idx_f = f_args_len - 1
         var last_ch_f = str_get(f_args_raw, last_idx_f)
         jika (last_ch_f == 41)
            var params_str = str_slice(f_args_raw, 0, last_idx_f)
            var params_trim = str_trim(params_str)

            var param_list = vec_create(6)
            var current_param = ""
            var idx_p = 0
            var params_len = str_len(params_trim)

            selama (idx_p < params_len)
               var ch_p = str_get(params_trim, idx_p)
               jika (ch_p == 44)
                  var trim_param = str_trim(current_param)
                  panggil vec_push(param_list, trim_param)
                  current_param = ""
               lain
                  var ch_str_p = str_slice(params_trim, idx_p, idx_p + 1)
                  current_param = str_concat(current_param, ch_str_p)
               tutup_jika
               idx_p = idx_p + 1
            tutup_selama
            jika (params_len > 0)
               var last_param = str_trim(current_param)
               panggil vec_push(param_list, last_param)
            tutup_jika

            var param_count = vec_len(param_list)
            var param_idx = 0

            selama (param_idx < param_count)
               var param_name = vec_get(param_list, param_idx)
               var param_trim = str_trim(param_name)
               var src_reg = ""
               jika (param_idx == 0)
                  src_reg = "rdi"
               lain_jika (param_idx == 1)
                  src_reg = "rsi"
               lain_jika (param_idx == 2)
                  src_reg = "rdx"
               lain_jika (param_idx == 3)
                  src_reg = "rcx"
               lain_jika (param_idx == 4)
                  src_reg = "r8"
               lain_jika (param_idx == 5)
                  src_reg = "r9"
               tutup_jika

               ; Push
               var push_asm = str_concat(s_push_q, param_trim)
               push_asm = str_concat(push_asm, s_close_br)
               panggil emit(push_asm)

               ; Mov
               var mov_param = str_concat(s_mov_mem, param_trim)
               mov_param = str_concat(mov_param, s_comma_space)
               mov_param = str_concat(mov_param, src_reg)
               panggil emit(mov_param)

               var vars_v = global_vars
               panggil vec_push(vars_v, param_trim)
               param_idx = param_idx + 1
            tutup_selama
         tutup_jika
      tutup_jika
   tutup_jika
tutup_fungsi

fungsi handle_fungsi_end()
   ; Handle: tutup_fungsi
   ; Emit function epilogue

   panggil emit("    pop rbp")
   panggil emit("    ret")
   current_func = ""
tutup_fungsi

; --- parser_helpers_import.fox ---
; Parser Helpers - Import Logic
; Handles: ambil (file import), Daftar (registry), Ambil (ID import), indeks
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi handle_import_ambil(line)
   ; Handle: ambil "filepath"
   ; Recursively parse imported file if not already processed

   var after_ambil = str_substring_after(line, 6)
   var path_raw = str_trim(after_ambil)
   var p_len = str_len(path_raw)

   jika (p_len > 2)
       var end_idx = p_len - 1
       var last_ch = str_get(path_raw, end_idx)

       ; Check for CR or other junk
       jika (last_ch != 34)
           end_idx = end_idx - 1
       tutup_jika

       var slice_len = end_idx - 1
       var import_path = str_slice(path_raw, 1, slice_len)

       var map_p = processed_files
       var is_proc = map_get(map_p, import_path)

       jika (is_proc == 1)
           var msg_skip = str_concat(s_msg_skip, import_path)
           panggil emit(msg_skip)
       lain
           panggil map_put(map_p, import_path, 1)

           cetak("[CODEGEN] Importing: ")
           cetak_str(import_path)

           var buf_imp = buffer_dari_file(import_path)
           jika (buf_imp == 0)
               cetak("Error: Import file not found: ")
               cetak_str(import_path)
           lain
               tipe buf_imp MemoryBuffer
               var imp_content = buf_imp.data_ptr
               var imp_lines = vec_create(50)
               panggil str_split_lines(imp_content, imp_lines)
               panggil parse_source_lines(imp_lines)
           tutup_jika
       tutup_jika
   tutup_jika
tutup_fungsi

fungsi handle_import_Daftar(line)
   ; Handle: Daftar "filepath" = ID-range
   ; Delegate to supplier system

   panggil parse_daftar_line(line)
tutup_fungsi

fungsi handle_import_Ambil(line)
   ; Handle: Ambil 310, 311, 312 (selective ID-based import)
   ; Parse IDs, lookup registry, extract blocks, parse recursively

   var after_ambil_caps = str_substring_after(line, 5)
   var ids_raw = str_trim(after_ambil_caps)

   ; Parse comma-separated IDs
   var id_list = vec_create(20)
   var current_num = ""
   var idx_a = 0
   var len_a = str_len(ids_raw)

   selama (idx_a < len_a)
       var ch_a = str_get(ids_raw, idx_a)
       jika (ch_a == 44)
           ; Comma found
           var num_trim_a = str_trim(current_num)
           var num_len_a = str_len(num_trim_a)
           jika (num_len_a > 0)
               var id_val_a = str_to_int(num_trim_a)
               panggil vec_push(id_list, id_val_a)
           tutup_jika
           current_num = ""
       lain
           ; Skip comments (semicolon)
           jika (ch_a == 59)
               idx_a = len_a
           lain
               var ch_str_a = str_slice(ids_raw, idx_a, idx_a + 1)
               current_num = str_concat(current_num, ch_str_a)
           tutup_jika
       tutup_jika
       idx_a = idx_a + 1
   tutup_selama

   ; Parse last number
   var last_trim_a = str_trim(current_num)
   var last_len_a = str_len(last_trim_a)
   jika (last_len_a > 0)
       var last_id_a = str_to_int(last_trim_a)
       panggil vec_push(id_list, last_id_a)
   tutup_jika

   ; Process each ID
   var count_a = vec_len(id_list)
   var i_a = 0
   selama (i_a < count_a)
       var id_a = vec_get(id_list, i_a)

       ; Check if already processed
       var filepath_a = get_file_for_id(id_a)
       jika (filepath_a != 0)
           var is_processed_a = is_block_processed(filepath_a, id_a)
           jika (is_processed_a == 0)
               ; Extract and parse block
               var extracted_lines = vec_create(50)
               var found_a = extract_block_by_id(filepath_a, id_a, extracted_lines)

               jika (found_a == 1)
                   panggil mark_block_processed(filepath_a, id_a)
                   cetak("[SUPPLIER] Loaded block:")
                   cetak(id_a)
                   cetak_str(filepath_a)
                   panggil parse_source_lines(extracted_lines)
               tutup_jika
           tutup_jika
       lain
           cetak("[SUPPLIER] Warning: ID not registered:")
           cetak(id_a)
       tutup_jika

       i_a = i_a + 1
   tutup_selama
tutup_fungsi

fungsi handle_import_indeks(line)
   ; Handle: indeks "filepath" (load ID registry)
   ; Delegate to supplier system

   panggil handle_indeks_line(line)
tutup_fungsi

; --- parser_helpers_jika.fox ---
; Parser Helpers - Conditional Logic (jika/lain/tutup_jika)
; Handles: jika, lain, lain_jika, tutup_jika
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi handle_jika(line)
   ; Handle: jika (condition)
   ; Parse condition, emit conditional jump

   label_counter = label_counter + 1
   var lbl_id = label_counter
   var stack = label_stack
   panggil vec_push(stack, lbl_id)

   var cond_raw = str_substring_after(line, 5)
   var cond_clean = str_trim(cond_raw)
   var c_len = str_len(cond_clean)
   var inner_cond = str_slice(cond_clean, 1, c_len - 2)

   var p1 = str_split_once(inner_cond, 32)
   var lhs = vec_get(p1, 0)
   var rest = vec_get(p1, 1)
   var p2 = str_split_once(rest, 32)
   var op = vec_get(p2, 0)
   var rhs = vec_get(p2, 1)

   ; LHS
   var lhs_mov = str_concat(s_mov_rax_v, lhs)
   lhs_mov = str_concat(lhs_mov, s_close_br)
   panggil emit(lhs_mov)

   ; RHS
   var cmp_asm = str_concat(s_cmp_rax, rhs)
   var rhs_first = str_get(rhs, 0)
   jika (rhs_first < 48)
      cmp_asm = str_concat(s_cmp_rax_v, rhs)
      cmp_asm = str_concat(cmp_asm, s_close_br)
   tutup_jika
   panggil emit(cmp_asm)

   var lbl_id_str = format_int(lbl_id)
   var end_label = str_concat(s_end_lbl, lbl_id_str)
   var jmp_instr = ""
   var op_char = str_get(op, 0)
   jika (op_char == 61)
      jmp_instr = s_jne
   lain_jika (op_char == 60)
      jmp_instr = s_jge
   lain_jika (op_char == 62)
      jmp_instr = s_jle
   tutup_jika
   var jump_asm = str_concat(jmp_instr, end_label)
   panggil emit(jump_asm)
tutup_fungsi

fungsi handle_lain_jika(line)
   ; Handle: lain_jika (condition)
   ; Currently not implemented

   panggil emit("    ; lain_jika not implemented")
tutup_fungsi

fungsi handle_lain()
   ; Handle: lain
   ; Emit else branch jump logic

   var stack_e = label_stack
   var len_e = vec_len(stack_e)
   var idx_e = len_e - 1
   var curr_id_e = vec_get(stack_e, idx_e)

   var curr_id_str = format_int(curr_id_e)
   var label_final = str_concat(s_final_lbl, curr_id_str)

   var jmp_final = str_concat(s_jmp, label_final)
   panggil emit(jmp_final)

   var label_else_start = str_concat(s_end_lbl, curr_id_str)
   var label_else_asm = str_concat(label_else_start, s_colon)
   panggil emit(label_else_asm)

   var new_id = curr_id_e + 1000000
   tipe stack_e Vector
   stack_e.length = stack_e.length - 1
   panggil vec_push(stack_e, new_id)
tutup_fungsi

fungsi handle_tutup_jika()
   ; Handle: tutup_jika
   ; Emit end label for if/else block

   var stack_j = label_stack
   var len_s = vec_len(stack_j)
   var last_idx = len_s - 1
   var lbl_id_j = vec_get(stack_j, last_idx)
   var prefix = s_end_lbl
   var real_id = lbl_id_j

   jika (lbl_id_j > 1000000)
      prefix = s_final_lbl
      real_id = lbl_id_j - 1000000
   tutup_jika

   var real_id_str = format_int(real_id)
   var end_label_j = str_concat(prefix, real_id_str)
   var lbl_asm = str_concat(end_label_j, s_colon)
   panggil emit(lbl_asm)

   tipe stack_j Vector
   stack_j.length = stack_j.length - 1
tutup_fungsi

; --- parser_helpers_loop.fox ---
; Parser Helpers - Loop Logic (selama/tutup_selama)
; Handles: selama, tutup_selama
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi handle_selama(line)
   ; Handle: selama (condition)
   ; Emit loop start label and conditional check

   label_counter = label_counter + 1
   var loop_id = label_counter
   var stack_l = label_stack
   panggil vec_push(stack_l, loop_id)

   var loop_id_str = format_int(loop_id)
   var start_label = str_concat(s_loop_start, loop_id_str)
   var start_asm = str_concat(start_label, s_colon)
   panggil emit(start_asm)

   var cond_raw_l = str_substring_after(line, 7)
   var cond_clean_l = str_trim(cond_raw_l)
   var c_len_l = str_len(cond_clean_l)
   var inner_cond_l = str_slice(cond_clean_l, 1, c_len_l - 2)
   var pl1 = str_split_once(inner_cond_l, 32)
   var lhs_l = vec_get(pl1, 0)
   var rest_l = vec_get(pl1, 1)
   var pl2 = str_split_once(rest_l, 32)
   var op_l = vec_get(pl2, 0)
   var rhs_l = vec_get(pl2, 1)

   var lhs_mov_l = str_concat(s_mov_rax_v, lhs_l)
   lhs_mov_l = str_concat(lhs_mov_l, s_close_br)
   panggil emit(lhs_mov_l)

   var cmp_asm_l = str_concat(s_cmp_rax, rhs_l)
   var rhs_first_l = str_get(rhs_l, 0)
   jika (rhs_first_l < 48)
      cmp_asm_l = str_concat(s_cmp_rax_v, rhs_l)
      cmp_asm_l = str_concat(cmp_asm_l, s_close_br)
   tutup_jika
   panggil emit(cmp_asm_l)

   var end_label_l = str_concat(s_loop_end, loop_id_str)
   var jmp_instr_l = ""
   var op_char_l = str_get(op_l, 0)
   jika (op_char_l == 61)
      jmp_instr_l = s_jne
   lain_jika (op_char_l == 60)
      jmp_instr_l = s_jge
   tutup_jika
   var jump_asm_l = str_concat(jmp_instr_l, end_label_l)
   panggil emit(jump_asm_l)
tutup_fungsi

fungsi handle_tutup_selama()
   ; Handle: tutup_selama
   ; Emit jump back to loop start and end label

   var stack_loop = label_stack
   var len_sl = vec_len(stack_loop)
   var last_idx_l = len_sl - 1
   var loop_id_j = vec_get(stack_loop, last_idx_l)
   tipe stack_loop Vector
   stack_loop.length = stack_loop.length - 1

   var loop_id_j_str = format_int(loop_id_j)
   var start_label_j = str_concat(s_loop_start, loop_id_j_str)
   var jmp_back = str_concat(s_jmp, start_label_j)

; --- parser_helpers_stmt.fox ---
; Parser Helpers - Statement Logic
; Handles: var, const, cetak, cetak_str, panggil, assignment, asm blocks, tipe, kembalikan
;
; NOTE: This file contains simplified statement handlers.
; Full implementation details are still in original parser.fox
; For Phase 1 refactoring, we keep main logic inline and extract to helpers progressively.
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi is_var_line(line)
   ; Check if line is var declaration
   var result = str_starts_with(line, "var ")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_const_line(line)
   ; Check if line is const declaration
   var result = str_starts_with(line, "const ")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_cetak_str_line(line)
   ; Check if line is cetak_str call
   var result = str_starts_with(line, "cetak_str(")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_cetak_line(line)
   ; Check if line is cetak call
   var result = str_starts_with(line, "cetak(")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_panggil_line(line)
   ; Check if line is panggil (function call)
   var result = str_starts_with(line, "panggil ")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_asm_mulai(line)
   ; Check if line is asm block start
   var result = str_starts_with(line, "asm_mulai")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_tutup_asm(line)
   ; Check if line is asm block end
   var result = str_starts_with(line, "tutup_asm")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_kembalikan(line)
   ; Check if line is return statement
   var result = str_starts_with(line, "kembalikan")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_tipe_assertion(line)
   ; Check if line is type assertion
   var result = str_starts_with(line, "tipe ")
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

fungsi is_assignment(line)
   ; Check if line is assignment (contains "=")
   var eq_idx = str_index_of(line, "=")
   var result = 0
   jika (eq_idx > 0)
      result = 1
   tutup_jika
   asm_mulai
   mov rax, [var_result]
   tutup_asm
tutup_fungsi

; ================================================================
; NOTE: Full implementation of statement handlers (var, cetak, panggil, etc.)
; are kept inline in parser.fox for now due to complexity (~350 lines total).
;
; These include:
; - handle_var_declaration() - var with struct instantiation, assignments
; - handle_cetak_str() - string printing
; - handle_cetak() - integer printing
; - handle_panggil() - function calls with arguments
; - handle_assignment() - variable assignments with operators
; - handle_asm_block() - inline assembly
; - handle_kembalikan() - return statements
; - handle_tipe_assertion() - type assertions for struct field access
; - handle_const() - constant declarations
;
; Phase 2 TODO: Extract these handlers once Phase 1 modular compile is working.
; ================================================================

; --- parser_helpers_struct.fox ---
; Parser Helpers - Struct Definition Logic
; Handles: struktur, tutup_struktur, struct fields
; NOTE: No Ambil here - inherits from parser.fox parent

fungsi handle_struct_begin(line)
   ; Handle: struktur StructName
   ; Initialize struct metadata (size, offsets map, name list)

   var after_struct = str_substring_after(line, 8)
   var struct_name_raw = str_trim(after_struct)
   current_struct_name = struct_name_raw
   in_struct_block = 1

   ; Initialize size to 0
   var ss = struct_sizes
   panggil map_put(ss, struct_name_raw, 0)

   ; Add to names list
   var sn = struct_names
   panggil vec_push(sn, struct_name_raw)

   cetak("[CODEGEN] Struct: ")
   cetak_str(struct_name_raw)
tutup_fungsi

fungsi handle_struct_end()
   ; Handle: tutup_struktur
   ; Close current struct definition block

   in_struct_block = 0
   current_struct_name = ""
tutup_fungsi

fungsi handle_struct_field(line)
   ; Handle: field_name field_type (inside struct block)
   ; Record field offset based on current struct size

   ; Parse field: field_name field_type
   var parts_field = str_split_once(line, 32)
   var field_name = vec_get(parts_field, 0)
   var field_name_t = str_trim(field_name)

   var field_name_len = str_len(field_name_t)
   jika (field_name_len > 0)
       ; Get current size
       var ss_f = struct_sizes
       var curr_size = map_get(ss_f, current_struct_name)

       ; Build offset key: "StructName_fieldname"
       var offset_key = str_concat(current_struct_name, "_")
       offset_key = str_concat(offset_key, field_name_t)

       ; Store offset
       var so_f = struct_offsets
       panggil map_put(so_f, offset_key, curr_size)

       ; Increment size (8 bytes per field)
       var new_size = curr_size + 8
       panggil map_put(ss_f, current_struct_name, new_size)
   tutup_jika
tutup_fungsi

; === PARSER DISPATCHERS ===

; --- parser_dispatch_cetak.fox ---
; Parser Dispatcher - Cetak Handling
; Handles: cetak("string"), cetak(var), cetak_str(var)

fungsi dispatch_cetak(line)
   ; Dispatch cetak and cetak_str statements

   ; --- CETAK STR ---
   var is_cetak_str = str_starts_with(line, "cetak_str")
   jika (is_cetak_str == 1)
      var after_cetak_str = str_substring_after(line, 9)
      var parts_str = str_split_once(after_cetak_str, 40)
      var args_part = vec_get(parts_str, 1)
      jika (args_part != 0)
         var args_len_s = str_len(args_part)
         jika (args_len_s > 0)
            var last_idx = args_len_s - 1
            var last_ch = str_get(args_part, last_idx)
            jika (last_ch == 41)
               var var_name = str_slice(args_part, 0, last_idx)
               var var_clean = str_trim(var_name)
               var asm1 = str_concat(s_mov_rsi_v, var_clean)
               asm1 = str_concat(asm1, s_close_br)
               panggil emit(asm1)
               panggil emit(s_print_ptr)
            tutup_jika
         tutup_jika
      tutup_jika
   tutup_jika

   ; --- CETAK ---
   jika (is_cetak_str == 0)
      var is_cetak = str_starts_with(line, "cetak")
      jika (is_cetak == 1)
         var after_cetak = str_substring_after(line, 5)
         var parts_c = str_split_once(after_cetak, 40)
         var args_c = vec_get(parts_c, 1)

         jika (args_c != 0)
            var args_len_c = str_len(args_c)
            jika (args_len_c > 0)
               var last_idx_c = args_len_c - 1
               var last_ch_c = str_get(args_c, last_idx_c)
               jika (last_ch_c == 41)
                  var content_c = str_slice(args_c, 0, last_idx_c)
                  var content_t = str_trim(content_c)
                  var first_char = str_get(content_t, 0)

                  jika (first_char == 34)
                     var ct_len = str_len(content_t)
                     var str_val = str_slice(content_t, 1, ct_len - 2)
                     str_counter = str_counter + 1
                     var str_cnt_str = format_int(str_counter)
                     var msg_label = str_concat(s_msg, str_cnt_str)
                     var len_label = str_concat(s_len, msg_label)

                     panggil emit(s_data)
                     var data_line = str_concat(s_indent, msg_label)
                     data_line = str_concat(data_line, s_db)
                     data_line = str_concat(data_line, str_val)
                     data_line = str_concat(data_line, s_db_end)
                     panggil emit(data_line)

                     var len_line = str_concat(s_indent, len_label)
                     len_line = str_concat(len_line, s_equ)
                     len_line = str_concat(len_line, msg_label)
                     panggil emit(len_line)

                     panggil emit(s_text)
                     var asm_rsi = str_concat(s_mov_rsi_lit, msg_label)
                     panggil emit(asm_rsi)
                     var asm_rdx = str_concat(s_mov_rdx_lit, len_label)
                     panggil emit(asm_rdx)
                     panggil emit(s_print)
                     panggil emit(s_nl)
                  lain
                     var is_num = 0
                     jika (first_char >= 48)
                        jika (first_char <= 57)
                           is_num = 1
                        tutup_jika
                     tutup_jika
                     jika (first_char == 45)
                        is_num = 1
                     tutup_jika
                     jika (is_num == 1)
                        var asm_mov = str_concat(s_mov_rax, content_t)
                        panggil emit(asm_mov)
                     lain
                        var asm_load = str_concat(s_mov_rax_v, content_t)
                        asm_load = str_concat(asm_load, s_close_br)
                        panggil emit(asm_load)
                     tutup_jika
                     panggil emit(s_print_int)
                     panggil emit(s_nl)
                  tutup_jika
               tutup_jika
            tutup_jika
         tutup_jika
      tutup_jika
   tutup_jika
tutup_fungsi

; --- parser_dispatch_control.fox ---
; Parser Dispatcher - Control Flow Handling
; Handles: fungsi, tutup_fungsi, jika, lain, lain_jika, tutup_jika, selama, tutup_selama

fungsi dispatch_control(line)
   ; Dispatch control flow statements to helpers

   var is_fungsi = str_starts_with(line, "fungsi")
   jika (is_fungsi == 1)
      panggil handle_fungsi_begin(line)
   tutup_jika

   var is_end_func = str_starts_with(line, "tutup_fungsi")
   jika (is_end_func == 1)
      panggil handle_fungsi_end()
   tutup_jika

   var is_jika = str_starts_with(line, "jika ")
   jika (is_jika == 1)
      panggil handle_jika(line)
   tutup_jika

   var is_lain_jika = str_starts_with(line, "lain_jika ")
   jika (is_lain_jika == 1)
       panggil handle_lain_jika(line)
   tutup_jika

   jika (is_lain_jika == 0)
      var is_lain_only = str_starts_with(line, "lain")
      jika (is_lain_only == 1)
         panggil handle_lain()
      tutup_jika
   tutup_jika

   var is_tutup_jika = str_starts_with(line, "tutup_jika")
   jika (is_tutup_jika == 1)
      panggil handle_tutup_jika()
   tutup_jika

   var is_selama = str_starts_with(line, "selama ")
   jika (is_selama == 1)
       panggil handle_selama(line)
   tutup_jika

   var is_tutup_selama = str_starts_with(line, "tutup_selama")
   jika (is_tutup_selama == 1)
       panggil handle_tutup_selama()
   tutup_jika
tutup_fungsi

; --- parser_dispatch_import.fox ---
; Parser Dispatcher - Import Handling
; Handles: ambil, Ambil, Daftar, indeks

fungsi dispatch_import(line)
   ; Dispatch import-related statements to helpers

   var is_ambil = str_starts_with(line, "ambil ")
   jika (is_ambil == 1)
       panggil handle_import_ambil(line)
   tutup_jika

   var is_daftar = str_starts_with(line, "Daftar")
   jika (is_daftar == 1)
       panggil handle_import_Daftar(line)
   tutup_jika

   var is_ambil_caps = str_starts_with(line, "Ambil")
   jika (is_ambil_caps == 1)
       panggil handle_import_Ambil(line)
   tutup_jika

   var is_indeks = str_starts_with(line, "indeks")
   jika (is_indeks == 1)
       panggil handle_import_indeks(line)
   tutup_jika
tutup_fungsi

; --- parser_dispatch_panggil.fox ---
; Parser Dispatcher - Panggil (Function Call) Handling
; Handles: panggil func_name(arg1, arg2, ...)

fungsi dispatch_panggil(line)
   ; Dispatch function call statements

   var is_panggil = str_starts_with(line, "panggil ")
   jika (is_panggil == 1)
      var content_after_panggil = str_substring_after(line, 8)
      var call_parts = str_split_once(content_after_panggil, 40)
      var func_name = vec_get(call_parts, 0)
      var func_name_clean = str_trim(func_name)
      var args_raw = vec_get(call_parts, 1)
      var args_clean = str_trim(args_raw)
      var args_len = str_len(args_clean)

      jika (args_len > 0)
         var last_char_idx = args_len - 1
         var last_char = str_get(args_clean, last_char_idx)
         jika (last_char == 41)
             var args_content = str_slice(args_clean, 0, last_char_idx)
             var args_trimmed = str_trim(args_content)

             var arg_list = vec_create(6)
             var current_arg = ""
             var idx_char = 0
             var args_total_len = str_len(args_trimmed)

             selama (idx_char < args_total_len)
                var ch = str_get(args_trimmed, idx_char)
                jika (ch == 44)
                   var trimmed_arg = str_trim(current_arg)
                   panggil vec_push(arg_list, trimmed_arg)
                   current_arg = ""
                lain
                   var ch_str = str_slice(args_trimmed, idx_char, idx_char + 1)
                   current_arg = str_concat(current_arg, ch_str)
                tutup_jika
                idx_char = idx_char + 1
             tutup_selama

             jika (args_total_len > 0)
                var last_arg = str_trim(current_arg)
                panggil vec_push(arg_list, last_arg)
             tutup_jika

             var arg_count = vec_len(arg_list)
             var arg_idx = 0
             selama (arg_idx < arg_count)
                var arg_val = vec_get(arg_list, arg_idx)
                var arg_val_t = str_trim(arg_val)
                var reg_name = ""
                jika (arg_idx == 0)
                   reg_name = "rdi"
                lain_jika (arg_idx == 1)
                   reg_name = "rsi"
                lain_jika (arg_idx == 2)
                   reg_name = "rdx"
                lain_jika (arg_idx == 3)
                   reg_name = "rcx"
                lain_jika (arg_idx == 4)
                   reg_name = "r8"
                lain_jika (arg_idx == 5)
                   reg_name = "r9"
                tutup_jika

                var first_ch_arg = str_get(arg_val_t, 0)
                var is_literal = 0
                jika (first_ch_arg >= 48)
                   jika (first_ch_arg <= 57)
                      is_literal = 1
                   tutup_jika
                tutup_jika
                jika (first_ch_arg == 45)
                   is_literal = 1
                tutup_jika

                var mov_asm = str_concat(s_mov_reg, reg_name)
                jika (is_literal == 1)
                   mov_asm = str_concat(mov_asm, s_comma)
                   mov_asm = str_concat(mov_asm, arg_val_t)
                lain
                   mov_asm = str_concat(mov_asm, s_comma_mem)
                   mov_asm = str_concat(mov_asm, arg_val_t)
                   mov_asm = str_concat(mov_asm, s_close_br)
                tutup_jika
                panggil emit(mov_asm)
                arg_idx = arg_idx + 1
             tutup_selama
         tutup_jika
      tutup_jika

      ; CRITICAL: Emit call instruction (was missing in original!)
      var call_asm = str_concat("    call ", func_name_clean)
      panggil emit(call_asm)
   tutup_jika
tutup_fungsi

; --- parser_dispatch_struct.fox ---
; Parser Dispatcher - Struct Handling
; Handles: struktur, tutup_struktur, struct fields

fungsi dispatch_struct(line)
   ; Dispatch struct-related statements to helpers

   var is_struktur = str_starts_with(line, "struktur")
   jika (is_struktur == 1)
       panggil handle_struct_begin(line)
   tutup_jika

   var is_tutup_struktur = str_starts_with(line, "tutup_struktur")
   jika (is_tutup_struktur == 1)
       panggil handle_struct_end()
   tutup_jika

   jika (in_struct_block == 1)
       jika (is_struktur == 0)
           jika (is_tutup_struktur == 0)
               panggil handle_struct_field(line)
           tutup_jika
       tutup_jika
   tutup_jika
tutup_fungsi

; --- parser_dispatch_var_simple.fox ---
; Parser Dispatcher - Var Simple + Entry Point
; Handles: var x = value, var y = a + b, var z = StructName(...)

fungsi dispatch_var(line)
   ; Main dispatcher for var declarations

   var is_var = str_starts_with(line, "var ")
   jika (is_var == 1)
      var content_after_var = str_substring_after(line, 4)
      var parts_eq = str_split_once(content_after_var, 61)
      var name_raw = vec_get(parts_eq, 0)
      var name = str_trim(name_raw)
      var val_raw = vec_get(parts_eq, 1)
      var val_str = str_trim(val_raw)

      ; Check for struct instantiation: StructName(args)
      var struct_paren = str_split_once(val_str, 40)
      var struct_name_candidate = vec_get(struct_paren, 0)
      var struct_args = vec_get(struct_paren, 1)

      jika (struct_args != 0)
         var handled = handle_var_struct(name, struct_name_candidate, struct_args)
         jika (handled == 1)
            kembalikan 0
         tutup_jika
      tutup_jika

      ; Handle simple var declaration + arithmetic
      var first_char = str_get(val_str, 0)
      var is_digit = 0
      jika (first_char >= 48)
         jika (first_char <= 57)
             is_digit = 1
         tutup_jika
      tutup_jika
      jika (first_char == 45)
         is_digit = 1
      tutup_jika

      var asm_mov = ""
      jika (is_digit == 1)
         asm_mov = str_concat(s_mov_rax, val_str)
      lain
         asm_mov = str_concat(s_mov_rax_v, val_str)
         asm_mov = str_concat(asm_mov, s_close_br)
      tutup_jika

      ; Arith
      var arith_parts = str_split_once(val_str, 32)
      var part1 = vec_get(arith_parts, 0)
      var rest_arith = vec_get(arith_parts, 1)
      var has_op = 0
      var op_char = 0
      var part2 = ""

      jika (rest_arith != 0)
         var len_rest = str_len(rest_arith)
         jika (len_rest > 0)
            var arith_p2 = str_split_once(rest_arith, 32)
            var op_str = vec_get(arith_p2, 0)
            part2 = vec_get(arith_p2, 1)
            op_char = str_get(op_str, 0)
            has_op = 1

            var p1_fc = str_get(part1, 0)
            var p1_is_digit = 0
            jika (p1_fc >= 48)
               jika (p1_fc <= 57)
                  p1_is_digit = 1
               tutup_jika
            tutup_jika
            jika (p1_is_digit == 1)
               asm_mov = str_concat(s_mov_rax, part1)
            lain
               asm_mov = str_concat(s_mov_rax_v, part1)
               asm_mov = str_concat(asm_mov, s_close_br)
            tutup_jika
         tutup_jika
      tutup_jika

      panggil emit(asm_mov)

      jika (has_op == 1)
         var p2_fc = str_get(part2, 0)
         var p2_is_digit = 0
         jika (p2_fc >= 48)
            jika (p2_fc <= 57)
               p2_is_digit = 1
            tutup_jika
         tutup_jika

         var operand_asm = ""
         jika (p2_is_digit == 1)
            operand_asm = part2
         lain
            operand_asm = str_concat(s_op_mem, part2)
            operand_asm = str_concat(operand_asm, s_close_br)
         tutup_jika

         var instr = ""
         jika (op_char == 43)
            instr = s_add
         lain_jika (op_char == 45)
            instr = s_sub
         lain_jika (op_char == 42)
            instr = s_mul
         tutup_jika
         var op_asm = str_concat(instr, operand_asm)
         panggil emit(op_asm)
      tutup_jika

      var var_label = str_concat(s_var_pref, name)
      var asm_store = str_concat(s_mov_mem_raw, var_label)
      asm_store = str_concat(asm_store, s_end_mem)
      panggil emit(asm_store)

      var vars_vec = global_vars
      panggil vec_push(vars_vec, name)

      ; Type tracking: infer type from literal or variable
      jika (is_digit == 1)
         ; Numeric literal - default to TYPE_INT (1)
         panggil register_variable_type(name, 1)
      lain
         ; Variable reference - inherit type or default to INT
         var src_type = get_variable_type(val_str)
         jika (src_type == 0)
            panggil register_variable_type(name, 1)
         lain
            panggil register_variable_type(name, src_type)
         tutup_jika
      tutup_jika
   tutup_jika
tutup_fungsi

; --- parser_dispatch_var_struct.fox ---
; Parser Dispatcher - Var Struct Instantiation
; Handles: var x = StructName(field1, field2, ...)

fungsi handle_var_struct(name, struct_name_candidate, struct_args)
   ; Handle struct instantiation: var x = MyStruct(a, b, c)

   var ss_check = struct_sizes
   var struct_size_val = map_get(ss_check, struct_name_candidate)

   jika (struct_size_val > 0)
      ; Allocate struct memory
      var size_str = format_int(struct_size_val)
      var mov_size = str_concat("    mov rax, ", size_str)
      panggil emit(mov_size)
      panggil emit("    call sys_alloc")
      panggil emit("    push rax    ; Save struct ptr")

      ; Parse and initialize fields
      var args_clean_len = str_len(struct_args)
      var args_inner = str_slice(struct_args, 0, args_clean_len - 1)
      var arg_list = vec_create(8)
      var current_arg = ""
      var arg_idx = 0
      var args_len = str_len(args_inner)

      selama (arg_idx < args_len)
         var arg_ch = str_get(args_inner, arg_idx)
         jika (arg_ch == 44)
            var arg_trim = str_trim(current_arg)
            panggil vec_push(arg_list, arg_trim)
            current_arg = ""
         lain
            var arg_ch_str = str_slice(args_inner, arg_idx, arg_idx + 1)
            current_arg = str_concat(current_arg, arg_ch_str)
         tutup_jika
         arg_idx = arg_idx + 1
      tutup_selama

      jika (args_len > 0)
         var last_arg = str_trim(current_arg)
         panggil vec_push(arg_list, last_arg)
      tutup_jika

      ; Initialize fields with offsets
      var field_count = vec_len(arg_list)
      var field_idx = 0
      var field_offset = 0

      selama (field_idx < field_count)
         var field_val = vec_get(arg_list, field_idx)
         var field_fc = str_get(field_val, 0)

         ; Load value to rbx
         var is_imm = 0
         jika (field_fc >= 48)
            jika (field_fc <= 57)
               is_imm = 1
            tutup_jika
         tutup_jika
         jika (field_fc == 45)
            is_imm = 1
         tutup_jika

         jika (is_imm == 1)
            var mov_rbx = str_concat("    mov rbx, ", field_val)
            panggil emit(mov_rbx)
         lain
            var mov_rbx_var = str_concat(s_mov_rbx_v, field_val)
            mov_rbx_var = str_concat(mov_rbx_var, s_close_br)
            panggil emit(mov_rbx_var)
         tutup_jika

         ; Store to [struct_ptr + offset]
         panggil emit("    mov rdx, [rsp]    ; Peek struct ptr")
         var off_str = format_int(field_offset)
         var store_field = str_concat("    mov [rdx + ", off_str)
         store_field = str_concat(store_field, "], rbx")
         panggil emit(store_field)

         field_offset = field_offset + 8
         field_idx = field_idx + 1
      tutup_selama

      ; Pop struct pointer to rax and store to variable
      panggil emit("    pop rax")
      var var_label_s = str_concat(s_var_pref, name)
      var asm_store_s = str_concat(s_mov_mem_raw, var_label_s)
      asm_store_s = str_concat(asm_store_s, s_end_mem)
      panggil emit(asm_store_s)

      var vars_vec_s = global_vars
      panggil vec_push(vars_vec_s, name)

      ; Type tracking: register struct variable
      panggil register_struct_variable(name, struct_name_candidate)

      kembalikan 1
   tutup_jika

   kembalikan 0
tutup_fungsi

; === MAIN ===
fungsi mulai(arg_unused1, arg_unused2)
  ; === INITIALIZATION ===
  panggil init_globals()
  panggil init_constants()
  panggil init_type_system()
  panggil init_supplier_system()

  ; === READ INPUT FILE ===
  var args_count = global_argc
  var args_ptr = global_argv

  jika (args_count < 2)
     cetak("Penggunaan: ./morph <file.fox>")
     asm_mulai
     mov rax, 60
     mov rdi, 1
     syscall
     tutup_asm
  tutup_jika

  var filename_ptr = 0
  asm_mulai
  mov rbx, [var_args_ptr]
  mov rax, [rbx + 8]
  mov [var_filename_ptr], rax
  tutup_asm

  cetak("Morph Self-Hosted Compiler v0.2 (Modular)")
  cetak("Compiling:")
  cetak_str(filename_ptr)

  var buf = buffer_dari_file(filename_ptr)
  jika (buf == 0)
     cetak("Fatal: Gagal membaca file input.")
     asm_mulai
     mov rax, 60
     mov rdi, 1
     syscall
     tutup_asm
  tutup_jika

  tipe buf MemoryBuffer
  var content = buf.data_ptr
  var lines = vec_create(100)
  panggil str_split_lines(content, lines)

  var line_count = vec_len(lines)
  cetak("Lines parsed:")
  cetak(line_count)

  ; === GENERATE ENTRY POINT ===
  panggil emit("section .text")
  panggil emit("    global _start")
  panggil emit("_start:")
  panggil emit("    call mulai")

  var asm_exit_1 = "    mov rax, 60"
  panggil emit(asm_exit_1)

  var asm_exit_2 = "    xor rdi, rdi"
  panggil emit(asm_exit_2)

  panggil emit("    syscall")

  ; === PARSE SOURCE CODE ===
  panggil parse_source_lines(lines)

  ; === GENERATE BSS SECTION ===
  panggil emit("section .bss")
  var vars_vec_2 = global_vars
  var vars_len = vec_len(vars_vec_2)
  var v_idx = 0

  var s_v_pref = "var_"

  selama (v_idx < vars_len)
     var v_name = vec_get(vars_vec_2, v_idx)
     var v_decl = str_concat(s_v_pref, v_name)
     var s_resq = ": resq 1"
     v_decl = str_concat(v_decl, s_resq)
     panggil emit(v_decl)
     v_idx = v_idx + 1
  tutup_selama

  ; === WRITE OUTPUT FILE ===
  var out_file = "output.asm"
  cetak("Writing output to:")
  cetak_str(out_file)

  var out_len = vec_len(output_lines)
  var k = 0
  var newline_str = str_newline()
  var nl_len = 1
  var write_fd = 0
  var flags = 577
  var mode = 420

  asm_mulai
  mov rsi, [var_out_file]
  mov rdx, [var_flags]
  mov rax, 2
  mov rdi, rsi
  mov rsi, rdx
  mov rdx, [var_mode]
  syscall
  mov [var_write_fd], rax
  tutup_asm

  jika (write_fd < 0)
     cetak("Error opening output.asm")
  lain
     selama (k < out_len)
        var line_content = vec_get(output_lines, k)
        var l_len = str_len(line_content)
        asm_mulai
        mov rdi, [var_write_fd]
        mov rsi, [var_line_content]
        mov rdx, [var_l_len]
        call sys_write_fd
        tutup_asm
        asm_mulai
        mov rdi, [var_write_fd]
        mov rsi, [var_newline_str]
        mov rdx, [var_nl_len]
        call sys_write_fd
        tutup_asm
        k = k + 1
     tutup_selama
     asm_mulai
     mov rdi, [var_write_fd]
     call sys_close
     tutup_asm

     ; Check for type errors before declaring success
     panggil report_type_errors()

     cetak("Success!")
  tutup_jika
tutup_fungsi
