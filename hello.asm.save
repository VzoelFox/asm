section .data
    newline db 10, 0
    ; --- Memory V2 Constants ---
    HEAP_CHUNK_SIZE equ 268435456 ; 256MB Chunk Size

    PROT_READ       equ 0x1
    PROT_WRITE      equ 0x2
    MAP_PRIVATE     equ 0x02
    MAP_ANONYMOUS   equ 0x20

    SYS_MMAP        equ 9
1    SYS_MUNMAP      equ 11

    ; Error Messages
    msg_oom db "Fatal: Out of Memory (Heap Exhausted)", 10, 0
    len_msg_oom equ $ - msg_oom

    msg_heap_fail db "Fatal: Heap Initialization Failed (mmap error)", 10, 0
    len_msg_heap_fail equ $ - msg_heap_fail

section .text
    global _start

_start:
    ; Initialize stack frame if needed
    mov rbp, rsp

    ; --- Memory V2 Initialization ---
    call sys_init_heap

    ; Call entry point
    call mulai

    ; Exit
    mov rax, 60
    xor rdi, rdi
    syscall

; --- Helper Functions ---

; sys_panic: Prints error to stderr (fd=2) and exits with code 1
; Input: RSI = message ptr, RDX = length
sys_panic:
    mov rax, 1      ; sys_write
    mov rdi, 2      ; stderr
    syscall

    mov rax, 60     ; sys_exit
    mov rdi, 1      ; status = 1
    syscall
    ret

; sys_init_heap: Allocates the first 256MB chunk
sys_init_heap:
    push rdi
    push rsi
    push rdx
    push r10
    push r8
    push r9
    push rax

    ; mmap(0, 256MB, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
    mov rax, SYS_MMAP
    mov rdi, 0                  ; hint = 0
    mov rsi, HEAP_CHUNK_SIZE    ; length
    mov rdx, 3                  ; PROT_READ | PROT_WRITE
    mov r10, 34                 ; MAP_PRIVATE | MAP_ANONYMOUS
    mov r8, -1                  ; fd = -1
    mov r9, 0                   ; offset = 0
    syscall

    ; Check for error (RAX < 0)
    cmp rax, 0
    jl .init_fail

    ; Save pointers
    mov [heap_start_ptr], rax   ; Start of the chunk
    mov [heap_current_ptr], rax ; Current bump pointer

    ; Calculate end
    add rax, HEAP_CHUNK_SIZE
    mov [heap_end_ptr], rax     ; End of the chunk

    pop rax
    pop r9
    pop r8
    pop r10
    pop rdx
    pop rsi
    pop rdi
    ret

.init_fail:
    mov rsi, msg_heap_fail
    mov rdx, len_msg_heap_fail
    call sys_panic
    ret ; Never reached

; sys_strcmp: Compare two strings (RSI, RDX)
; Output: RAX (1 if equal, 0 if not)
sys_strcmp:
    push rsi
    push rdx
    push rbx
    push rcx

.loop:
    mov al, [rsi]
    mov bl, [rdx]

    cmp al, bl
    jne .not_equal

    test al, al
    jz .equal       ; Reached null terminator and they are equal

    inc rsi
    inc rdx
    jmp .loop

.not_equal:
    mov rax, 0
    jmp .done

.equal:
    mov rax, 1

.done:
    pop rcx
    pop rbx
    pop rdx
    pop rsi
    ret

; print_string_ptr: Prints null-terminated string pointed by RSI
print_string_ptr:
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push rax

    ; Calculate length using scasb
    mov rdi, rsi    ; rdi = string start
    xor rax, rax    ; rax = 0 (search for null)
    mov rcx, -1     ; unlimited scan
    repne scasb     ; scan

    not rcx         ; rcx = -length - 2 (roughly)
    dec rcx         ; adjust

    mov rdx, rcx    ; length

    mov rax, 1      ; sys_write
    mov rdi, 1      ; stdout
    ; RSI is already buffer
    syscall

    call print_newline

    pop rax
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret

; sys_alloc: Allocates N bytes from dynamic heap (V2)
; Input: RAX = size
; Output: RAX = pointer
sys_alloc:
    push rbx
    push rdx
    push rcx

    ; Align size to 8 bytes
    add rax, 7
    and rax, -8

    mov rbx, [heap_current_ptr]  ; Current pointer

    ; Calculate potential new pointer
    mov rcx, rbx
    add rcx, rax                ; rcx = new_ptr (potential)

    ; Check bounds
    mov rdx, [heap_end_ptr]
    cmp rcx, rdx
    jg .out_of_memory

    ; Success: update bump pointer
    mov [heap_current_ptr], rcx

    ; Return old pointer (rbx)
    mov rax, rbx

    pop rcx
    pop rdx
    pop rbx
    ret

.out_of_memory:
    mov rsi, msg_oom
    mov rdx, len_msg_oom
    call sys_panic
    ; Never reached
    mov rax, 0
    pop rcx
    pop rdx
    pop rbx
    ret

; sys_mem_checkpoint: Saves current heap pointer (returns it in RAX)
sys_mem_checkpoint:
    mov rax, [heap_current_ptr]
    ret

; sys_mem_rollback: Restores heap pointer from RAX
; Input: RAX = saved_heap_ptr
sys_mem_rollback:
    ; Safety Check: Rollback ptr must be >= start_ptr AND <= end_ptr
    mov rbx, [heap_start_ptr]
    cmp rax, rbx
    jl .invalid_rollback

    mov rbx, [heap_end_ptr]
    cmp rax, rbx
    jg .invalid_rollback

    ; Perform Rollback
    mov [heap_current_ptr], rax
    mov rax, 1 ; Success
    ret

.invalid_rollback:
    mov rax, 0 ; Fail
    ret

; sys_mem_rewind: Same as rollback, alias
sys_mem_rewind:
    jmp sys_mem_rollback

; sys_reset_memory: Resets the arena pointer to the start (Snapshot Cleanup)
sys_reset_memory:
    push rax
    mov rax, [heap_start_ptr]
    mov [heap_current_ptr], rax
    pop rax
    ret

; sys_free_memory: Returns the chunk to OS (Daemon Collector support)
sys_free_memory:
    push rax
    push rdi
    push rsi

    mov rax, SYS_MUNMAP
    mov rdi, [heap_start_ptr]
    mov rsi, HEAP_CHUNK_SIZE
    syscall

    ; Clear pointers to avoid use-after-free
    mov qword [heap_start_ptr], 0
    mov qword [heap_current_ptr], 0
    mov qword [heap_end_ptr], 0

    pop rsi
    pop rdi
    pop rax
    ret

; sys_strlen: Calculates length of null-terminated string
; Input: RSI = string ptr
; Output: RAX = length
sys_strlen:
    push rcx
    push rdi

    mov rdi, rsi
    xor rax, rax
    mov rcx, -1
    repne scasb
    not rcx
    dec rcx
    mov rax, rcx

    pop rdi
    pop rcx
    ret

; sys_memcpy: Copies bytes
; Input: RDI = dest, RSI = src, RCX = count
sys_memcpy:
    push rax
    push rcx
    push rsi
    push rdi

    rep movsb

    pop rdi
    pop rsi
    pop rcx
    pop rax
    ret

; sys_str_concat: Concatenates two strings
; Input: RSI = str1, RDX = str2
; Output: RAX = new string ptr
sys_str_concat:
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi
    push r8 ; len1
    push r9 ; len2

    ; 1. Calc len1
    call sys_strlen
    mov r8, rax

    ; 2. Calc len2
    push rsi
    mov rsi, rdx
    call sys_strlen
    mov r9, rax
    pop rsi

    ; 3. Total size = len1 + len2 + 1
    mov rax, r8
    add rax, r9
    inc rax

    ; 4. Alloc
    call sys_alloc
    mov rbx, rax    ; dest ptr

    ; 5. Copy str1
    mov rdi, rbx
    mov rcx, r8
    call sys_memcpy

    ; 6. Copy str2
    lea rdi, [rbx + r8]
    mov rsi, rdx
    mov rcx, r9
    call sys_memcpy

    ; 7. Null terminate
    mov rdi, rbx
    add rdi, r8
    add rdi, r9
    mov byte [rdi], 0

    ; Return ptr
    mov rax, rbx

    pop r9
    pop r8
    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret

; sys_read: Reads N bytes from stdin to new heap buffer
; Input: RAX = max_size
; Output: RAX = buffer_pointer
sys_read:
    push rbx
    push rcx
    push rdx
    push rsi
    push rdi

    ; 1. Allocate buffer
    mov rbx, rax    ; rbx = size
    call sys_alloc  ; rax = buffer_pointer

    ; 2. Syscall Read
    mov rsi, rax    ; buf
    mov rdx, rbx    ; count
    mov rax, 0      ; sys_read
    mov rdi, 0      ; stdin
    syscall

    ; Null-terminate the input for safety
    mov byte [rsi + rax], 0

    ; We return the buffer pointer (which is in RSI)
    mov rax, rsi

    pop rdi
    pop rsi
    pop rdx
    pop rcx
    pop rbx
    ret

; print_string: Expects address in RSI, length in RDX
print_string:
    mov rax, 1          ; sys_write
    mov rdi, 1          ; stdout
    syscall
    ret

; print_newline:
print_newline:
    mov rax, 1
    mov rdi, 1
    mov rsi, newline
    mov rdx, 1
    syscall
    ret

; print_int: Expects integer in RAX
print_int:
    push rbp
    mov rbp, rsp
    sub rsp, 32         ; Reserve buffer space

    cmp rax, 0
    jne .check_sign

    ; Print '0'
    mov byte [rsp+30], '0'
    lea rsi, [rsp+30]
    mov rdx, 1
    call print_string
    leave
    ret

.check_sign:
    mov rbx, 31         ; Buffer index (start from end)

    ; Check if negative
    test rax, rax
    jns .convert_loop

    ; It is negative
    neg rax             ; Make positive
    push rax            ; Save value

    ; Print '-' immediately
    mov byte [rsp+16], '-'  ; Temporary scratch for char
    lea rsi, [rsp+16]
    mov rdx, 1
    push rcx ; Save regs used by syscall
    mov rax, 1
    mov rdi, 1
    syscall
    pop rcx

    pop rax             ; Restore positive value

.convert_loop:
    mov rcx, 10
    xor rdx, rdx
    div rcx             ; RAX / 10 -> RAX quot, RDX rem
    add dl, '0'
    mov [rsp+rbx], dl
    dec rbx
    test rax, rax
    jnz .convert_loop

    ; Print buffer
    lea rsi, [rsp+rbx+1] ; Start of string
    mov rdx, 31
    sub rdx, rbx        ; Length

    mov rax, 1          ; sys_write
    mov rdi, 1          ; stdout
    syscall

    leave
    ret

; --- JSON Primitive Parsers (Kernel Level) ---

; sys_json_skip_whitespace: Skips whitespace chars (space, tab, newline)
; Input: RSI = buffer_ptr
; Output: RSI = new_buffer_ptr (at first non-whitespace)
sys_json_skip_whitespace:
    push rax
.skip_loop:
    mov al, [rsi]
    cmp al, 32  ; space
    je .next
    cmp al, 9   ; tab
    je .next
    cmp al, 10  ; newline
    je .next
    cmp al, 13  ; CR
    je .next

    ; Not whitespace
    jmp .done_skip

.next:
    inc rsi
    jmp .skip_loop

.done_skip:
    pop rax
    ret

; sys_json_parse_string: Parses "quoted string" to a new allocated buffer
; Input: RSI = buffer_ptr (points to opening quote or content)
; Output: RAX = new_string_ptr, RSI = buffer_ptr (after closing quote)
sys_json_parse_string:
    push rbx
    push rcx
    push rdx

    ; Check for opening quote
    cmp byte [rsi], 34 ; "
    jne .not_quote
    inc rsi ; Skip opening quote

.not_quote:
    mov rbx, rsi ; Save start of content

    ; Scan for length
    xor rcx, rcx
.scan_len:
    mov al, [rsi]
    cmp al, 34 ; "
    je .found_end
    cmp al, 0
    je .error_unterminated
    inc rsi
    inc rcx
    jmp .scan_len

.found_end:
    ; rcx = length of content
    ; Alloc new buffer
    mov rax, rcx
    inc rax ; +1 for null
    push rsi ; Save current position (closing quote)
    push rcx ; Save length

    call sys_alloc ; RAX = new buffer

    pop rcx ; Restore length
    pop rsi ; Restore closing quote pos

    ; Copy content
    ; dest = RAX, src = RBX, len = RCX
    push rdi
    push rsi

    mov rdi, rax
    mov rsi, rbx
    rep movsb

    mov byte [rdi], 0 ; Null terminate

    pop rsi
    pop rdi

    inc rsi ; Move past closing quote
    ; RAX already has new pointer

    pop rdx
    pop rcx
    pop rbx
    ret

.error_unterminated:
    mov rax, 0
    pop rdx
    pop rcx
    pop rbx
    ret

; sys_json_parse_number: Parses integer from buffer
; Input: RSI = buffer_ptr
; Output: RAX = integer value, RSI = buffer_ptr (after number)
sys_json_parse_number:
    push rbx
    push rcx
    push rdx

    xor rax, rax ; Result
    xor rbx, rbx ; Temp digit

    ; TODO: Handle negative sign?

.num_loop:
    mov cl, [rsi]
    cmp cl, '0'
    jl .done_num
    cmp cl, '9'
    jg .done_num

    sub cl, '0'
    movzx rbx, cl

    imul rax, 10
    add rax, rbx

    inc rsi
    jmp .num_loop

.done_num:
    pop rdx
    pop rcx
    pop rbx
    ret
mulai:
section .data
    msg_0 db "Halo dari Morph!", 0
    len_msg_0 equ $ - msg_0
section .text
    mov rsi, msg_0
    mov rdx, len_msg_0
    call print_string
    call print_newline
    ret
section .bss
    heap_start_ptr   resq 1
    heap_current_ptr resq 1
    heap_end_ptr     resq 1
section .text
    mov rax, 60
    xor rdi, rdi
    syscall
