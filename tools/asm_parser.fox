; ASM Parser Module - Lightweight assembly parser untuk morph_robot
; Fokus: Parse line-by-line tanpa dependencies berat

; === LINE TYPE DETECTION ===

fungsi is_empty_line(line)
    ; Check if line is empty or whitespace only
    var len = str_len(line)
    jika (len == 0)
        kembalikan 1
    tutup_jika

    ; Check first char (simple whitespace check)
    var first_char = 0
    asm_mulai
    mov rsi, [var_line]
    movzx rax, byte [rsi]
    mov [var_first_char], rax
    tutup_asm

    ; ASCII: 32=space, 9=tab, 10=newline
    jika (first_char == 32)
        kembalikan 1
    tutup_jika
    jika (first_char == 9)
        kembalikan 1
    tutup_jika
    jika (first_char == 10)
        kembalikan 1
    tutup_jika

    kembalikan 0
tutup_fungsi

fungsi is_comment_line(line)
    ; Check if line starts with ';'
    var len = str_len(line)
    jika (len == 0)
        kembalikan 0
    tutup_jika

    var first_char = 0
    asm_mulai
    mov rsi, [var_line]
    movzx rax, byte [rsi]
    mov [var_first_char], rax
    tutup_asm

    ; ASCII: 59 = ';'
    jika (first_char == 59)
        kembalikan 1
    tutup_jika

    kembalikan 0
tutup_fungsi

fungsi is_label_line(line)
    ; Check if line contains ':' (label definition)
    ; Format: "label_name:"

    var len = str_len(line)
    jika (len < 2)
        kembalikan 0
    tutup_jika

    ; Scan for ':' character
    var i = 0
    selama (i < len)
        var ch = 0
        asm_mulai
        mov rsi, [var_line]
        mov rcx, [var_i]
        add rsi, rcx
        movzx rax, byte [rsi]
        mov [var_ch], rax
        tutup_asm

        ; ASCII: 58 = ':'
        jika (ch == 58)
            kembalikan 1
        tutup_jika

        i = i + 1
    tutup_selama

    kembalikan 0
tutup_fungsi

fungsi is_directive_line(line)
    ; Check if line is assembler directive
    ; Examples: "section .text", "global _start", "default rel"

    ; Look for common directives
    var len = str_len(line)
    jika (len < 4)
        kembalikan 0
    tutup_jika

    ; Check for 'section', 'global', 'default', 'extern', etc
    ; Simple check: first char is alphabetic and contains space

    var first_char = 0
    asm_mulai
    mov rsi, [var_line]
    movzx rax, byte [rsi]
    mov [var_first_char], rax
    tutup_asm

    ; ASCII: 65-90 (A-Z), 97-122 (a-z)
    var is_alpha = 0
    jika (first_char >= 65)
        jika (first_char <= 90)
            is_alpha = 1
        tutup_jika
    tutup_jika
    jika (first_char >= 97)
        jika (first_char <= 122)
            is_alpha = 1
        tutup_jika
    tutup_jika

    kembalikan is_alpha
tutup_fungsi

fungsi is_instruction_line(line)
    ; Check if line is an assembly instruction
    ; Typically starts with whitespace then instruction mnemonic

    var len = str_len(line)
    jika (len < 3)
        kembalikan 0
    tutup_jika

    var first_char = 0
    asm_mulai
    mov rsi, [var_line]
    movzx rax, byte [rsi]
    mov [var_first_char], rax
    tutup_asm

    ; Instructions typically start with whitespace
    ; ASCII: 32=space, 9=tab
    jika (first_char == 32)
        kembalikan 1
    tutup_jika
    jika (first_char == 9)
        kembalikan 1
    tutup_jika

    kembalikan 0
tutup_fungsi

; === INSTRUCTION PARSING ===

fungsi extract_instruction_mnemonic(line)
    ; Extract instruction name (e.g., "mov", "push", "call")
    ; Input: "    mov rax, rbx"
    ; Output: "mov"

    ; TODO: Implement string tokenization
    ; For now, return hardcoded stub

    kembalikan "stub"
tutup_fungsi

fungsi count_push_instructions(line)
    ; Count push instructions in line
    ; Returns 1 if contains "push", 0 otherwise

    var len = str_len(line)
    var i = 0
    var found_p = 0
    var found_u = 0
    var found_s = 0
    var found_h = 0

    selama (i < len - 3)
        var c0 = 0
        var c1 = 0
        var c2 = 0
        var c3 = 0

        asm_mulai
        mov rsi, [var_line]
        mov rcx, [var_i]
        add rsi, rcx
        movzx rax, byte [rsi]
        mov [var_c0], rax
        movzx rax, byte [rsi + 1]
        mov [var_c1], rax
        movzx rax, byte [rsi + 2]
        mov [var_c2], rax
        movzx rax, byte [rsi + 3]
        mov [var_c3], rax
        tutup_asm

        ; Check for "push" (ASCII: p=112, u=117, s=115, h=104)
        jika (c0 == 112)
            jika (c1 == 117)
                jika (c2 == 115)
                    jika (c3 == 104)
                        kembalikan 1
                    tutup_jika
                tutup_jika
            tutup_jika
        tutup_jika

        i = i + 1
    tutup_selama

    kembalikan 0
tutup_fungsi

fungsi count_pop_instructions(line)
    ; Similar to count_push_instructions
    ; Check for "pop" (ASCII: p=112, o=111, p=112)

    var len = str_len(line)
    var i = 0

    selama (i < len - 2)
        var c0 = 0
        var c1 = 0
        var c2 = 0

        asm_mulai
        mov rsi, [var_line]
        mov rcx, [var_i]
        add rsi, rcx
        movzx rax, byte [rsi]
        mov [var_c0], rax
        movzx rax, byte [rsi + 1]
        mov [var_c1], rax
        movzx rax, byte [rsi + 2]
        mov [var_c2], rax
        tutup_asm

        jika (c0 == 112)  ; 'p'
            jika (c1 == 111)  ; 'o'
                jika (c2 == 112)  ; 'p'
                    kembalikan 1
                tutup_jika
            tutup_jika
        tutup_jika

        i = i + 1
    tutup_selama

    kembalikan 0
tutup_fungsi

fungsi has_undefined_symbol(line)
    ; Check for undefined symbol pattern: "[var_"
    ; This indicates reference to variable that might not be defined

    var len = str_len(line)
    var i = 0

    selama (i < len - 4)
        var c0 = 0
        var c1 = 0
        var c2 = 0
        var c3 = 0
        var c4 = 0

        asm_mulai
        mov rsi, [var_line]
        mov rcx, [var_i]
        add rsi, rcx
        movzx rax, byte [rsi]
        mov [var_c0], rax
        movzx rax, byte [rsi + 1]
        mov [var_c1], rax
        movzx rax, byte [rsi + 2]
        mov [var_c2], rax
        movzx rax, byte [rsi + 3]
        mov [var_c3], rax
        movzx rax, byte [rsi + 4]
        mov [var_c4], rax
        tutup_asm

        ; Check for "[var_" (ASCII: [=91, v=118, a=97, r=114, _=95)
        jika (c0 == 91)
            jika (c1 == 118)
                jika (c2 == 97)
                    jika (c3 == 114)
                        jika (c4 == 95)
                            kembalikan 1
                        tutup_jika
                    tutup_jika
                tutup_jika
            tutup_jika
        tutup_jika

        i = i + 1
    tutup_selama

    kembalikan 0
tutup_fungsi

; === STATISTICS ===

fungsi count_lines_by_type(lines_vec)
    ; Count different types of lines
    ; Returns array: [total, empty, comments, labels, directives, instructions]

    var total = vec_len(lines_vec)
    var empty = 0
    var comments = 0
    var labels = 0
    var directives = 0
    var instructions = 0

    var i = 0
    selama (i < total)
        var line = vec_get(lines_vec, i)

        jika (is_empty_line(line) == 1)
            empty = empty + 1
        lain
            jika (is_comment_line(line) == 1)
                comments = comments + 1
            lain
                jika (is_label_line(line) == 1)
                    labels = labels + 1
                lain
                    jika (is_directive_line(line) == 1)
                        directives = directives + 1
                    lain
                        jika (is_instruction_line(line) == 1)
                            instructions = instructions + 1
                        tutup_jika
                    tutup_jika
                tutup_jika
            tutup_jika
        tutup_jika

        i = i + 1
    tutup_selama

    cetak("Total lines: ")
    cetak(total)
    cetak("Empty: ")
    cetak(empty)
    cetak("Comments: ")
    cetak(comments)
    cetak("Labels: ")
    cetak(labels)
    cetak("Directives: ")
    cetak(directives)
    cetak("Instructions: ")
    cetak(instructions)

    kembalikan total
tutup_fungsi
