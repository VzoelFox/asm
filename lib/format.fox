struktur FormatBuffer
  data_ptr int
  length int
  capacity int
tutup_struktur

fungsi format_buffer_buat(capacity)
  var buf = FormatBuffer(0, 0, capacity)
  var ptr = 0

  ; Allocate raw memory for data
  asm_mulai
  mov rax, [var_capacity]
  call sys_alloc
  mov [var_ptr], rax
  ; Initialize with empty string (null terminator at start)
  mov byte [rax], 0
  tutup_asm

  buf.data_ptr = ptr

  ; Return struct pointer
  asm_mulai
  mov rax, [var_buf]
  tutup_asm
tutup_fungsi

fungsi format_append(buf, text)
  ; Logic: concat current data + text
  ; Current data is at buf.data_ptr
  ; We can reuse sys_str_concat, but we need to update the pointer in buf.data_ptr
  ; NOTE: sys_str_concat allocates NEW memory. This is simple but leaks old memory (no GC yet).
  ; It's acceptable for now.

  var old_ptr = buf.data_ptr
  var new_ptr = 0

  asm_mulai
  mov rsi, [var_old_ptr]
  mov rdx, [var_text]
  call sys_str_concat
  mov [var_new_ptr], rax
  tutup_asm

  buf.data_ptr = new_ptr

  ; Update length
  var len = 0
  asm_mulai
  mov rsi, [var_new_ptr]
  call sys_strlen
  mov [var_len], rax
  tutup_asm

  buf.length = len

  ; Return buffer ptr
  asm_mulai
  mov rax, [var_buf]
  tutup_asm
tutup_fungsi

fungsi format_int(value)
  ; Convert int to string
  ; We don't have a direct helper for this exposed yet, but print_int logic exists in codegen.
  ; We need a sys_int_to_str helper or implement it here.
  ; Implementing here in ASM is cleaner for library.

  var res_ptr = 0

  asm_mulai
  ; Alloc 32 bytes for buffer
  mov rax, 32
  call sys_alloc
  mov [var_res_ptr], rax

  mov rdi, rax          ; RDI = buffer start
  mov rax, [var_value]  ; RAX = integer value

  ; Handle 0
  cmp rax, 0
  jne .check_sign
  mov byte [rdi], '0'
  mov byte [rdi+1], 0
  jmp .done_fmt

.check_sign:
  mov rbx, 0            ; Is negative?
  test rax, rax
  jns .convert
  neg rax
  mov rbx, 1            ; Set negative flag

.convert:
  mov rcx, 10
  mov rsi, rdi          ; Save start
  add rdi, 20           ; Start filling from end (safe margin)
  mov byte [rdi], 0     ; Null terminator
  dec rdi

.loop:
  xor rdx, rdx
  div rcx
  add dl, '0'
  mov [rdi], dl
  dec rdi
  test rax, rax
  jnz .loop

  ; Add sign if needed
  cmp rbx, 1
  jne .finalize
  mov byte [rdi], '-'
  dec rdi

.finalize:
  inc rdi               ; Point to first char

  ; Move to beginning of buffer (optional, but good for neatness)
  ; rdi is current start, rsi is allocated start.
  ; sys_memcpy(dest=rsi, src=rdi, len=strlen(rdi)+1)

  push rsi
  push rdi

  ; Calc length
  push rdi
  pop rsi               ; RSI = src string
  call sys_strlen
  mov rcx, rax
  inc rcx               ; + null terminator

  pop rdi               ; Restore src
  pop rsi               ; Restore dest (allocated start)

  push rdi
  pop rdx               ; RDX = src (swap for helper if needed, but we do manual rep movsb)

  ; Manual copy
  mov rsi, rdx          ; Source
  mov rdi, rsi          ; Dest (Wait, rsi was popped as allocated start. So RDI = allocated start)
                        ; Ah, stack management above is confusing.
                        ; Let's just return the pointer inside the buffer?
                        ; No, 'sys_alloc' returns [ptr].
                        ; If we return ptr+offset, we waste memory but it works.
                        ; Let's simpler: just return RDI (the start of valid string).
                        ; BUT we need to store it in [var_res_ptr] if we want to return it.

  ; Correct logic: Move string to start of buffer so we return the malloc'd pointer
  ; rsi (popped) = allocated start
  ; rdx (current) = string start
  ; rcx (calculated) = length + 1

  mov rdi, rsi          ; Dest = allocated start
  mov rsi, rdx          ; Src = current pos inside buffer

  ; Rep Movsb
  cld
  rep movsb

  ; Now string is at allocated start.
  ; [var_res_ptr] already holds the allocated start address.

.done_fmt:
  tutup_asm

  asm_mulai
  mov rax, [var_res_ptr]
  tutup_asm
tutup_fungsi

fungsi format_bool(value)
  var res = ""
  jika (value == 1)
     res = "true"
  lain
     res = "false"
  tutup_jika

  asm_mulai
  mov rax, [var_res]
  tutup_asm
tutup_fungsi

fungsi format_print(text)
  cetak_str(text)
tutup_fungsi
