; Memory Pool System
; Granular ID: 100-110

### 100
struktur MemoryPool
    start_ptr int
    current_ptr int
    end_ptr int
    object_size int
    free_list int ; Pointer to head of free list (LIFO)
tutup_struktur

### 101
fungsi pool_create(object_size, capacity)
    var pool_size = object_size * capacity
    var ptr = sys_mmap(0, pool_size, 3, 34, -1, 0)

    ; FIX: Calculate end_ptr separately to avoid parser bug with expressions in struct args
    var end_ptr = ptr + pool_size

    var pool = MemoryPool(ptr, ptr, end_ptr, object_size, 0)
    return pool
tutup_fungsi

### 102
fungsi pool_acquire(pool, needed_size)
    tipe pool MemoryPool

    ; 1. Check free list
    jika (pool.free_list != 0)
        var free_obj = pool.free_list
        ; Pop from free list
        ; Assume first 8 bytes of free object point to next
        ; free_list = *free_obj

        var next_free = 0
        asm_mulai
        mov rbx, [var_free_obj]
        mov rax, [rbx]
        mov [var_next_free], rax
        tutup_asm

        pool.free_list = next_free
        return free_obj
    tutup_jika

    ; 2. Allocate from bump pointer
    var ptr = pool.current_ptr
    var next_ptr = ptr + needed_size

    jika (next_ptr > pool.end_ptr)
        return 0 ; OOM in pool
    tutup_jika

    pool.current_ptr = next_ptr
    return ptr
tutup_fungsi

### 103
fungsi pool_release(pool, ptr)
    tipe pool MemoryPool

    ; Push to free list (LIFO)
    ; *ptr = pool.free_list
    ; pool.free_list = ptr

    var old_head = pool.free_list

    asm_mulai
    mov rbx, [var_ptr]
    mov rax, [var_old_head]
    mov [rbx], rax
    tutup_asm

    pool.free_list = ptr
tutup_fungsi
